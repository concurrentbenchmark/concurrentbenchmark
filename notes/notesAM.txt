Typos

A.1.1
- The process \( \Pout{x}{a}{P} \) is an \emph{output}, which can send the value \( v \) via \( x \), then continue as \( P \).

should it be  \( \Pout{x}{v}{P} \) [DONE]


- P{v/w} should be P{v/l} and explanation of what is substituted changed accordingly

 [DONE]
A.1.4

- \Presd{x_1}{y_1}{\Presd{x_2}{y_2}{(\Ppar{\Pout{x_1}{a}{\Pin{y_2}{l}{\Pend}}}{\Pout{y}{x_2}{\Pin{y_1}{l}{\Pend}}})}}

y shoud be y_2
 [DONE]

- def of Gamma: we should allow variable names (or values? That seems strange)  there

G := ...
| G, l: T
 
see rule T-var (should be l, rather than v?)
[DONE]

- where do we use the judgment lin(T)?

- Do we mean "all **other* types are linear?

- Would a dual presentation (with
intutionistic and linear context separeted) be cleaner? I'm working on that, in the sense that I have one but I have to concince myself it's equivalent.

- Give a reference where this calculus come from. [DONE]

- Is the update operation
partial? Seems undefined on base/end.

- Since there are three typing judgments, perhaps we should not call them all as T-*

- T-RES: should we use +? namely G+ x: T+ x: dual T.  Unless we mean
  that in RES x and y are fresh (hence comma is fine), However, then
  it is inconsistent with T-OUT (+ x: T) and similarly T-IN. If x
  occurs lineary in the context of the conclusion it has to go to
  Gamma_1, hence it cannot occur in Gamma_3, so why the update.

- is T-VAR even necessary? It cannot be for v in any case

  

- "our type system will mantain 2 invariants": more then 2, also that values are base

------------
Notes to abstract:

A.1.3 in finite case, barbed-bisim still needs to be defined so as to have
some (co)inductive principle to use in the proof. Perhaps make clear that
it is not simply a fixed point requiring only case analysis.

Thm 1. Would it make any difference (i.e. more interesting) to prove conguence, rather than equivalence here?
 

A.3.2: the sentence "all types are linear" is strange. The qualifier
lin(T) is never used in the rules.

Insisting that context are sets and detailing what a split is: sounds
like a nod towards the implementation. Not that I have a better
suggestion.

% OBSOLETE

A.3.1 Note to myself: "binary" restriction: do we need n-any binary or nu x. nu y. etc will do

A.2.1 there is a lot of repetitions here wrt A.1.1 and A.3.1
explaining the notation for processes, convention for names etc. If
this is intentional, I find it a bit distracting.
