\documentclass[adraft,copyright,creativecommons]{eptcs}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{bm}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{draftwatermark}
\usepackage{underscore}
\usepackage[T1]{fontenc}

\SetWatermarkText{Draft}
\SetWatermarkScale{2}
\SetWatermarkColor[gray]{0.90}

\input{../macros.tex}

\title{The Concurrent Calculi Formalisation Benchmark\\{\normalsize(Talk Proposal)}}
\def\titlerunning{The Concurrent Calculi Formalisation Benchmark (Talk Proposal)}

\author{
     Marco Carbone \institute{IT University of Copenhagen} \email{maca@itu.dk}
\and David Castro-Perez \institute{University of Kent} \email{D.Castro-Perez@kent.ac.uk}
\and Francisco Ferreira \institute{Royal Holloway, University of London} \email{Francisco.FerreiraRuiz@rhul.ac.uk}    \and Lorenzo Gheri \institute{University of Oxford} \email{lorenzo.gheri@cs.ox.ac.uk}
\and Frederik Krogsdal Jacobsen \institute{Technical University of Denmark \thanks{The work was done while visiting the University of Oxford}} \email{fkjac@dtu.dk}
\and Alberto Momigliano \institute{Università degli Studi di Milano} \email{momigliano@di.unimi.it}
\and Luca Padovani \institute{Università di Camerino} \email{luca.padovani@unicam.it}
\and Alceste Scalas \institute{Technical University of Denmark} \email{alcsc@dtu.dk}
\and Martin Vassor \institute{University of Oxford} \email{martin.vassor@cs.ox.ac.uk}
\and Nobuko Yoshida \institute{University of Oxford} \email{nobuko.yoshida@cs.ox.ac.uk}
}
\def\authorrunning{Carbone, Castro-Perez, Ferreira, Gheri, Jacobsen, Momigliano, Padovani, Scalas, Vassor \& Yoshida}

\begin{document}
\maketitle

\begin{abstract}
  The POPLMark challenge has sparked a flurry of work to move us closer to a world in which every paper on programming languages is accompanied by machine-checked proofs.
  However, POPLMark (and its follow-up POPLMark Reloaded) were explicitly limited in scope,
  with benchmark problems that do not address concurrency. For this reason, we propose a new collection of benchmark problems with a focus on the issues encountered when mechanizing message-passing concurrency using process calculi.
  Our benchmark problems concern the mechanization of linear handling of environments, scope extrusion, and coinductive reasoning.
  Like previous benchmarks, our goal is to clarify, compare and advance the state of the art.
\end{abstract}

\section{Introduction}
The programming language community has increasingly embraced mechanizations since the influential POPLMark challenge~\cite{POPLMark}, but we are still far from the vision of a mechanized proof accompanying every paper in the field.
Since POPLMark, the number of papers with accompanying mechanized proofs has grown steadily, but many mechanizations still rely on ad hoc techniques.
The POPLMark Reloaded challenge~\cite{POPLMarkReloaded} aimed to identify and develop best practices and tool support for proofs using logical relations.
The authors of both POPLMark and POPLMark Reloaded were careful to note that their benchmarks were only a beginning, and the previous benchmarks specifically mention reasoning about concurrency using coinduction and linear environments as points for future work.

Papers in concurrency theory do often include mechanized proofs, but our experience is that choosing techniques and tools remains a challenge with few guidelines.
We propose a new collection of benchmark problems specifically designed to tackle the issues encountered when mechanizing message-passing concurrency using process calculi.
A goal of our collection of benchmark problems is to enable comparison between techniques and push for the development of guidelines and tutorials, and our challenge problems are a simple setting in which to demonstrate and compare techniques.
Another goal is to strengthen the culture of mechanization by rallying the community to collaborate on exploring and developing new tools and techniques.

We have identified three key aspects which cause issues when mechanizing concurrency theory:
\begin{itemize}
\item Linearity in behavioural type systems
\item Scope extrusion in name passing systems
\item Infinite behaviour modelled coinductively
\end{itemize}
Each part of our benchmark exercises the three aspects independently to enable comparison and to keep the challenge problems small.
The three aspects are of course not the only ones that may cause issues in mechanizations, but they are fundamental to the field and will thus appear in most mechanizations of concurrency theory.
Actual mechanizations will additionally often require more than just one aspect, but we will not address the combination of techniques except as optional bonus challenges.

In the rest of this paper we discuss the design of the challenge and briefly describe the three challenge problems.
The appendix contains the full text of the challenge problems and pen and paper solutions.

\section{Design of the challenge}
Our challenge problems cannot address every technique and subfield at once.
We have identified three key aspects fundamental to concurrency theory mechanizations and designed our challenge problems to exercise these.
Like previous benchmark authors, we would like to stress that our challenge is not meant to be comprehensive: applications such as multiparty session types, choreographies, conversation types and psi-calculi are not directly covered by our challenge problems.
Most applications will however still need the basic techniques that our challenge problems exercise.

We have designed our challenge problems to exercise the three aspects independently, and they can be solved individually and in any order.
We have designed each problem to be small and easy to understand with a basic knowledge of textbook concurrency theory and process calculi.
Solutions to our challenge problems should be compared on three measures:
\begin{itemize}
\item The mechanization overhead, this being the amount of manually written infrastructure and setup needed to express the definitions in the mechanization.
\item The adequacy of the formal statements in the mechanization, i.e.\ whether the proven theorems are easily recognizable as the theorems from the challenge.
\item The cost of entry for the tools and techniques employed, i.e.\ the difficulty of learning to use the techniques.
\end{itemize}
Solutions to our challenges do not need to strictly follow the definitions and techniques set out in the problem text, but solutions which deviate from the original challenges will need to present more elaborate argumentation for their adequacy.

\section{The challenge problems}
In this section we will briefly describe our three challenge problems, referring to the appendix for the full text and pen and paper solution to each problem.

Our \textbf{linearity challenge} (Appendix~\ref{sec:challenge:linearity-beh-types}) is to prove type preservation (also known as subject reduction) for a process calculus with a session type system.
Session type systems require linear handling of typing contexts, and the proof involves reasoning about the linearity of context splitting operations.

In name passing systems, scope extrusion is the expansion of the scope of a name when the name is sent outside of its original scope.
Our \textbf{scope extrusion challenge} (Appendix~\ref{sec:challenge:name-passing-scope-extrusion}) is to prove that barbed bisimulation is an equivalence relation for an untyped name passing caluclus without infinite behaviour, but with non-deterministic choice.
The proof involves reasoning about names that are ``in the process'' of being scope extruded, which presents issues with some approaches to binders.

Our \textbf{coinduction challenge} (Appendix~\ref{sec:challenge:coinduction}) is to prove that strong barbed bisimulation is an equivalence relation for an untyped calculus of communicating systems with (infinite) replication of processes.
The proof involves reasoning coinductively about the infinite behaviours of the replication operator.

We invite anyone interested to send us solutions to the challenge problems and to publish experience reports detailing the advantages and disadvantages of their approaches.
The interested reader can find more information about the current status of the challenge at:
\begin{center}
  \url{https://concurrentbenchmark.github.io/}
\end{center}

\bibliographystyle{eptcs}
% \bibliography{bibliography}
\bibliography{../references}

\appendix

\section{Challenges}
\input{../challenges.tex}

\end{document}