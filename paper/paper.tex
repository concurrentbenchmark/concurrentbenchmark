\documentclass[runningheads]{llncs}
\synctex=1
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{mathpartir}
\usepackage{cite}
\usepackage{bm}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{hyperref}
\usepackage[inline]{enumitem}
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage[status=draft]{fixme}
\fxsetup{theme=color}

\input{../macros.tex}

\begin{document}

\title{The Concurrent Calculi Formalisation Benchmark}

\maketitle

\begin{abstract}
  The POPLMark challenge and its follow-up POPLMark Re\-loaded sparked a flurry of
  work on machine-checked proofs, and fostered the adoption of proof
  mechanisation in programming language research.  However, both POPLMark and
  POPLMark Reloaded were purposely limited in scope, with benchmark problems
  that do not address concurrency-related issues.
  %
  For this reason, we propose a new collection of benchmark problems with a
  focus on the challenges and issues that typically arise when mechanising
  message-passing concurrency using process calculi.  Our benchmark problems
  address three key topics: linearity, scope extrusion, and coinductive
  reasoning.  The goal of this new challenge is to clarify, compare, and advance
  the state of the art, fostering the adoption of proof mechanisation in future
  research on message-passing concurrency.

\keywords{Mechanisation \and Process calculi \and Benchmark \and Coinduction \and Scope extrusion \and Linearity}
\end{abstract}

\section{Introduction}


The abstract of the influential POPLMark challenge~\cite{POPLMark} starts with
an important question: \emph{``How close are we to a world where every paper on
programming languages is accompanied by an electronic appendix with
machine-checked proofs?''} The introduction of the POPLMark
challenge spearheaded a shift towards publications that include
mechanised proofs, fostering the progress of proof assistants,
libraries, and best practices.  Later on, the follow-up POPLMark
Reloaded challenge~\cite{POPLMarkReloaded} has encouraged the development of
best practices and tool support for proofs using logical relations.

The authors of both POPLMark and POPLMark Reloaded explicitly
note that their benchmarks were only a beginning.  Furthermore, they
specifically mention reasoning about concurrency using coinduction and
linear environments as points for future work.  In this spirit, in order to
further increase the reach of the POPLMark challenges, we propose a new
collection of benchmark problems specifically designed to address typical issues
that arise when mechanising message-passing concurrency using process calculi.

Several papers in the realm of process calculi already include mechanised proofs
(e.g.~\cite{DBLP:conf/pldi/Castro-Perez0GY21,DBLP:conf/tacas/CastroFY20,lmcs:9985,
  DBLP:journals/jar/CruzFilipeMP23, Tirore:2023}), or
discuss proof mechanisation techniques
(e.g.~\cite{DBLP:journals/jar/BengtsonPW16, DBLP:conf/tphol/Gay01,
  DBLP:conf/ppdp/Thiemann19, DBLP:conf/forte/ZalakainD21}).  However, our
experience is that choosing the appropriate proof mechanisation techniques and
tools remains a significant challenge with few guidelines.  This often leads
researchers towards trial-and-error, attempting sub-optimal and ad-hoc
solutions; this increases the overall effort required for proof mechanisation,
and hampers the reuse of techniques and results.
%
Therefore, it is our opinion that the research community in message-passing
concurrency (and more specifically, in process calculi) will benefit from a set
of solutions exploring different ways of mechanising typical problems in the
field.

Like the authors of the POPLMark challenges, we seek to
answer a number of questions:
\begin{enumerate}[label=\textbf{(Q\arabic*)},leftmargin=10mm]
\item\label{item:rq1} What is the current state of the art in mechanising process calculi?
\item\label{item:rq2} What techniques and best practices can be recommended when starting formalisation projects within concurrency theory?
\item\label{item:rq3} What improvements are needed to make mechanisation tools more user-friendly with regards to the issues faced when mechanising process calculi?
\end{enumerate}

We have identified three key aspects which typically cause difficulties when
mechanising concurrency theory: \emph{linearity}, \emph{scope extrusion},
and \emph{coinductive reasoning} for infinite behaviours.
Our benchmark problems are designed to focus on these aspects (discussed
in more detail in \cref{sec:challenge-problems}), with three main goals:

\begin{enumerate}[label=\textbf{(G\arabic*)},leftmargin=10mm]
\item\label{item:goal-comperison-accessibility} Enable the comparison of
  different proof mechanisation approaches, making the challenges accessible to
  mechanisation experts who may not be familiar with concurrency theory.

\item\label{item:goal-tutorials} Encourage the development of guidelines and
  tutorials demonstrating and comparing the many available proof mechanisation
  techniques, libraries, and proof assistant features.

\item\label{item:goal-reusability} Prioritise the exploration of mechanisation
  techniques that may be useful and reusable for future research.
\end{enumerate}

We also aim at strengthening the culture of mechanisation, by rallying the
community to collaborate on exploring and developing new tools and techniques.

The three aspects we selected (linearity, scope extrusion, coinduction) are of
course not the only ones that may cause issues in mechanisations --- but they
are fundamental to concurrency theory, and they emerge in most mechanisations.
The mechanisation of novel research results often requires addressing more than
just one of these aspects at once --- and we see the combination of techniques
as a next step beyond the scope of this challenge (we discuss this in
\cref{sec:going-beyond}).

% Our challenge problems are designed to stimulate progress on answering these questions by providing simple environments in which to demonstrate, evaluate, and compare the many tools and techniques available.
% While the challenge problems themselves are thus not of scientific interest, we expect that the best practices and mechanisations developed by solving the challenge problems will also be useful for future research.

We have begun collecting solutions to our challenges on our website:
%
\begin{center}
  \url{https://concurrentbenchmark.github.io/}
\end{center}
%
In the longer term, we expect to use the website for promoting best practices,
tutorials and guidelines derived from solutions to our challenges.
We encourage anyone interested to try the challenges using their
favourite tools and techniques, and to send us their solutions.

\paragraph{Outline of this paper.}
In \cref{sec:challenge-problems} we describe in more detail the three key
aspects of our challenge problems.  We discuss our design choices in
\cref{sec:design-discussion}, and possible extensions and further topics in
\cref{sec:going-beyond}.
The full challenges, including proofs, are available in \cref{app:challenges}.

\section{The challenges}\label{sec:challenge-problems}
In this section we briefly describe the three aspects of our challenges, referring to the appendix for the full text of each one.

\subsection{Linearity}
Our \textbf{linearity challenge} (Appendix~\ref{sec:challenge:linearity-beh-types}) is to prove type preservation (also known as subject reduction) for a process calculus with a minimal
session typing system (without delegation of communication channels, to avoid overlapping with the scope
extrusion challenge below).
Session type systems require linear handling of typing contexts, and the key
issue of this challenge is reasoning about the linearity of context splitting operations.

\subsection{Scope extrusion}
In name-passing systems, scope extrusion is the expansion of the scope of a name (i.e.~a communication channel) that is sent from one process to another.
Our \textbf{scope extrusion challenge} (Appendix~\ref{sec:challenge:name-passing-scope-extrusion}) is to prove the equivalence between the reduction semantics and the labelled transition system (LTS) semantics of a process calculus (up-to structural congruence).
The key issue of this challenge is reasoning about names that are ``in the process'' of being scope-extruded, which often presents difficulties for the mechanisation of binders.

\subsection{Coinduction}
Our \textbf{coinduction challenge} (Appendix~\ref{sec:challenge:coinduction}) is to prove a context lemma involving \emph{strong barbed congruence} for a limited calculus with (infinite) replication of processes.
The key issue of this challenge is the coinductive reasoning about the infinite behaviours of the replication operator.

\section{Design of the benchmark}\label{sec:design-discussion}

In this section, we outline the factors considered in designing the
benchmark challenges. We start with some general remarks, then
describe the individual design considerations for each challenge problem.

% We have identified three key aspects fundamental to mechanisations of concurrent calculi and designed our challenge problems to exercise these.
Like the previous POPLMark and POPLMark Reloaded challenges, our challenge is not meant to be comprehensive:
applications such as multiparty session types~\cite{10.1145/2827695,10.1145/3290343}, choreographies~\cite{DBLP:journals/jar/CruzFilipeMP23}, conversation types~\cite{DBLP:journals/tcs/CairesV10}, psi-calculi~\cite{lmcs:696}, or encodings between different calculi~\cite{DBLP:journals/iandc/Gorla10,DBLP:journals/iandc/DardhaGS17,DBLP:conf/ecoop/ScalasDHY17} are not directly covered.  Still, these (and other) proof mechanisation applications will need the basic techniques that our challenge problems exercise:
as per our design goal \ref{item:goal-reusability},
our problems are drawn from the basic metatheory of process calculi (instead
of requiring the development of new theory), and focus on well-known theorems
and results that involve interesting proof techniques that may be reused in further work.

To achieve our design goal \ref{item:goal-comperison-accessibility},
we have designed our challenge problems to exercise the three aspects (linearity, scope extrusion, coinduction) independently, and they can be solved individually and in any order.
We have designed each problem to be small and easy to understand with basic knowledge of textbook concurrency theory, process calculi, and type theory.  The process calculus used in each challenge
focuses on the features we want to exercise, and omits all constructs
(such as choices) that would complicate the mechanisation without bringing tangible
benefits and insights.  (It is of course possible to reintroduce the omitted
constructs, but we leave this as a possibility for a future benchmark challenge.)

The minimality and uniformity of the calculi also allows us to target our design
goal \ref{item:goal-tutorials}, i.e.~encouraging the development guidelines and
tutorials for the mechanisation of concurrency theory.

% While our challenges require reasoning about binders, which was the main topic of the original POPLMark, they also require other techniques.
% Our challenges also require reasoning about logical relations which goes above the reasoning involved in POPLMark Reloaded.

% Our challenge problems do not include reasoning about encodings. While
% this kind of reasoning is common in the field, it does not require any
% different reasoning techniques in a concurrency setting than in any
% other setting.

\subsection{Linearity}
For our challenge on linear reasoning we have chosen a safety theorem
for a session type system since this allows us to involve linear
reasoning without many definitions. Accordingly, we have chosen not to
include channel delegation and to use a reduction instead of a
transition system semantics.

Linearity is of course interesting in many other subfields of programming languages, but we have chosen to base our challenge on a session type system primarily due to the common use of session types in concurrency theory.

Inspired by Vasconcelos~\cite{Vasconcelos2012}, we use a syntax where
restriction binds two names. This presentation makes the duality
of the two names obvious in the type system.

We have chosen a simple notion of well-formedness for our challenge,
and do not for instance consider deadlocked processes. While more
sophisticated notions of well-formedness are also interesting, the
proofs of these properties are more complicated and would thus make
the challenge more difficult and less focused on the linear
aspects of the system.

\subsection{Scope extrusion}
This is the challenge most closely related to the original POPLMark
challenge since it concerns the properties of binders in restrictions.
It is not clear that the techniques used to solve the POPLMark challenges about binders can be easily extended to reasoning about scope extrusion.
Notably, techniques like Higher Order Abstract Syntax, or well-scoped
De\ Bruijn indices do not have the concept of free variables. It is
not immediately obvious how to encode the operational semantics in
this kind of system.


\subsection{Coinduction}
%\fxerror{
% ``Proper'' barbs with a structural congruence in coinduction instead of LTS semantics?
%}

Our coinduction challenge concerns strong barbed bisimulation and congruence.
Though weak barbed congruence is a more common behavioural equivalence for \(\pi\)-terms, we avoid having to abstract over the number of internal transitions when considering the strong notions of equivalence, thus simplifying the theory.

We have chosen not to include delegation in the coinduction challenge since it is orthogonal to our primary aim of exploring coinductive proof techniques.

\subsection{Evaluation criteria}
The idea of our benchmark is to obtain evidence towards answering questions \cref{item:rq1,item:rq2,item:rq3}, and we are thus interested in not only the solutions, but in the experience of solving the challenges with the chosen approach.
Solutions to our challenges should be compared on three measures: the mechanisation overhead, this being the amount of manually written infrastructure and setup needed to express the definitions in the mechanisation; the adequacy of the formal statements in the mechanisation, i.e.\ whether the proven theorems are easily recognisable as the theorems from the challenge; and the cost of entry for the tools and techniques employed, i.e.\ the difficulty of learning to use the techniques.
Solutions to our challenges do not need to strictly follow the definitions and lemmas set out in the problem text, but solutions which deviate from the original challenges need to present more elaborate argumentation for their adequacy.

\section{Going beyond the challenge problems}\label{sec:going-beyond}

As with the POPLMark and POPLMark Reloaded challegnes, this challenge is
intended to be useful, but it does not aim at covering every possible
problem in the area. Our benchmark can be extended in two
dimensions: further expanding and combining the current challenges,
and addressing calculi and features not covered by the current challenges.
We discuss these dimensions in the rest if this section.

\paragraph{Extending and combining the current challenges.}
The proposed challenges try to minimise the overlap of the techniques
and aspects they exercise (linearity, scope extrusion, coinduction) --- but most
research on concurrency theory combines some or all such aspects. An interesting second round of formalisations could
entail combining the features of the challenges.

In \cref{tab:extensions} we consider the following three extensions: first, the
addition of choice to the type level and the process level. Second, the addition
of recursion (and recursion types for typed systems). And finally, the
addition of channel delegation to those calculi that do not already
support it.

\begin{table}
  \caption{Possible extensions of the challenges. Each suitable extension is marked ``+''. \label{tab:extensions}}
  \begin{center}
    \begin{tabular}{|r|c|c|c|}
      \hline
      & Linearity & Scope extrusion & Coinduction \\
      \hline
      Choice & $+$ & $+$  & $+$ \\
      \hline
      Recursive types & $+$  & $+$ & \\
      \hline
      Delegation & $+$ & & $+$ \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

\paragraph{Addressing new calculi and new features.}
Extending in this dimension
means proposing new challenges to cover for different features of
message passing calculi, or to cover different proof mechanisation features.

Some interesting aspects of message passing calculi to explore in
further challenges could be multiparty session types, and
choreographies because their definitions and meta-theory have aspects
that we do not cover here (e.g.: representing well formed global types
and projection as a partial function). Although, dually, some aspects
that we cover here do appear in these problems. Also, one could easily
design a challenge that goes beyond our coinduction challenge, by
exploring different notions of bisimilarity (barbed, or weak, etc.),
and trace equivalence.

On the side of proof assistants, the current challenge proposes
mechanising the proofs of theorems. An interesting venue to explore
would be to take advantage of other proof assistant features. For
example, proof assistants are often able to produce certified code (by
using code extraction, or compiling and running their definitions).
Additionally, while having effective automation in our current
challenge is possible, a challenge could be designed with the explicit
objective of automating aspects of the proofs. And finally, a
challenge could propose the integration with other formal reasoning
tools, namely model checkers. These tools are in common use in the
field --- and combining automated proofs with proof assistants
offers the potential to ease the path for attempting larger proofs
with less effort.

Ultimately, the current challenges can be extended in several
worthwhile directions, and we look forward to a future when they
indeed are extended. We see the current challenge as setting
the foundation for those future extensions. It is our expectation that
the solutions of those hypothetical challenges will build on solutions
to this challenge.

\appendix
\section{Challenges}\label{app:challenges}
\input{../challenges/challenges.tex}

\bibliographystyle{splncs04}
\bibliography{../references}

\end{document}
