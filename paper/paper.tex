\documentclass[runningheads]{llncs}
\synctex=1
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{mathpartir}
\usepackage{cite}
\usepackage{bm}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{hyperref}
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage[status=draft]{fixme}
\fxsetup{theme=color}

\input{../macros.tex}

\begin{document}

\title{The Concurrent Calculi Formalisation Benchmark}

\author{
     Marco Carbone \inst{1}\orcidID{0000-0001-9479-2632}
\and David Castro-Perez \inst{2}\orcidID{0000-0002-6939-4189}
\and Francisco Ferreira \inst{3}\orcidID{0000-0001-8494-7696}
\and Lorenzo Gheri \inst{4}\orcidID{0000-0002-3191-7722}
\and Frederik Krogsdal Jacobsen \inst{5}\orcidID{0000-0003-3651-8314}
\and Alberto Momigliano \inst{6}\orcidID{0000-0003-0942-4777}
\and Luca Padovani \inst{7}\orcidID{0000-0001-9097-1297}
\and Alceste Scalas \inst{5}\orcidID{0000-0002-1153-6164}
\and Martin Vassor \inst{8}\orcidID{0000-0002-2057-0495}
\and Nobuko Yoshida \inst{8}\orcidID{0000-0002-3925-8557}
\and Daniel Zackon \inst{9}\orcidID{0009-0008-6153-2955}
}

\institute{
     IT University of Copenhagen, Copenhagen, Denmark \email{maca@itu.dk}
\and University of Kent, Canterbury, United Kingdom \email{D.Castro-Perez@kent.ac.uk}
\and Royal Holloway, University of London, Egham, United Kingdom \email{Francisco.FerreiraRuiz@rhul.ac.uk}
\and University of Liverpool, Liverpool, United Kingdom \email{Lorenzo.Gheri@liverpool.ac.uk}
\and Technical University of Denmark, Kgs. Lyngby, Denmark \email{fkjac@dtu.dk}, \email{alcsc@dtu.dk}
\and Università degli Studi di Milano, Milan, Italy \email{momigliano@di.unimi.it}
\and Università di Camerino, Camerino, Italy \email{luca.padovani@unicam.it}
\and University of Oxford, Oxford, United Kingdom \email{martin.vassor@cs.ox.ac.uk}, \email{nobuko.yoshida@cs.ox.ac.uk}
\and McGill University, Montreal, Canada \email{daniel.zackon@mail.mcgill.ca}
}

\authorrunning{M. Carbone et al.}

\maketitle

\begin{abstract}
  The POPLMark challenge and its follow-up POPLMark Reloaded sparked a flurry of
  work on machine-checked proofs, and fostered the adoption of proof
  mechanisation in programming language research.  However, both POPLMark and
  POPLMark Reloaded were purposely limited in scope, with benchmark problems
  that do not address concurrency-related issues.
  %
  For this reason, we propose a new collection of benchmark problems with a
  focus on the challenges and issues that typically arise when mechanising
  message-passing concurrency using process calculi.  Our benchmark problems
  address three key topics: linearity, scope extrusion, and coinductive
  reasoning.  The goal of this new challenge is to clarify, compare, and advance
  the state of the art, fostering the adoption of proof mechanisation in future
  research on message-passing concurrency.

\keywords{Mechanisation \and Process calculi \and Benchmark \and Coinduction \and Scope extrusion \and Linearity}
\end{abstract}

\section{Introduction}


The abstract of the influential POPLMark challenge~\cite{POPLMark} starts with
an important question: \emph{``How close are we to a world where every paper on
programming languages is accompanied by an electronic appendix with
machine-checked proofs?''} The introduction of the POPLMark
challenge spearheaded a shift towards publications that include
mechanised proofs, fostering the progress of proof assistants,
libraries, and best practices.  Later on, the follow-up POPLMark
Reloaded challenge~\cite{POPLMarkReloaded} has encouraged the development of
best practices and tool support for proofs using logical relations.

The authors of both POPLMark and POPLMark Reloaded explicitly
note that their benchmarks were only a beginning.  Furthermore, they
specifically mention reasoning about concurrency using coinduction and
linear environments as points for future work.  In this spirit, in order to
further increase the reach of the POPLMark challenges, we propose a new
collection of benchmark problems specifically designed to address typical issues
that arise when mechanising message-passing concurrency using process calculi.

Large scale mechanisation of concurrency theory is already possible,
\fxwarning{Citations?}
%(Paragraphs about related work in this vein)
and several papers in the realm of process calculi do include mechanised proofs
(e.g.~\cite{DBLP:conf/pldi/Castro-Perez0GY21,DBLP:conf/tacas/CastroFY20,lmcs:9985,
  DBLP:journals/jar/CruzFilipeMP23, Tirore:2023}), or
discuss proof mechanisation techniques
(e.g.~\cite{DBLP:journals/jar/BengtsonPW16, DBLP:conf/tphol/Gay01,
  DBLP:conf/ppdp/Thiemann19, DBLP:conf/forte/ZalakainD21}).  However, our
experience is that choosing the appropriate proof mechanisation techniques and
tools remains a significant challenge with few guidelines.  This often leads
researchers towards trial-and-error, attempting sub-optimal and ad-hoc
solutions; this increases the overall effort required by proof mechanisation,
and hampers the reuse of techniques and results.

Therefore, it is our opinion that the research community in message-passing
concurrency (and more specifically, in process calculi) will benefit from a set
of solutions exploring different ways of mechanising typical problems in the
field. Like the authors of the previous POPLMark challenges, we thus seek to
answer a number of questions:
\begin{enumerate}
\item What is the current state of the art in mechanising process calculi?
\item What techniques and best practices can be recommended when starting formalisation projects within concurrency theory?
\item What improvements are needed to make mechanisation tools more user-friendly with regards to the issues faced when mechanising process calculi?
\end{enumerate}

\subsection*{Benchmark design goals and considerations}%

We have identified three key aspects which typically cause difficulties when
mechanising concurrency theory: \emph{linearity}, \emph{scope extrusion} in
name-passing systems, and \emph{coinductive reasoning} for infinite behaviours.
Our main goals are:

\begin{enumerate}
\item Enable the comparison of different proof mechanisation approaches, making
  the challenges accessible to mechanisation experts who may not be familiar
  with concurrency theory. To this end, we strive to keep the challenge problems
  orthogonal: our collection of benchmark problems is designed to exercise one
  of the aforementioned three aspects independently from the others, and include
  as little syntax and as few definitions as possible.

\item Encourage the development of guidelines and tutorials demonstrating and
  comparing the many available proof mechanisation techniques, libraries, and
  proof assistant features.  Therefore, our challenge problems strive for
  minimality, and adopt a simple and uniform notation.

\item Prioritise the exploration of mechanisation techniques that may be useful
  and reusable for future research. To this end, our problems are drawn from the
  basic metatheory of process calculi (instead of requiring the development of
  new theory), and focus on well-known theorems and results that involve
  interesting proof techniques.
\end{enumerate}

We also see the goals above as a stepping stone towards strengthening the
culture of mechanisation, by rallying the community to collaborate on exploring
and developing new tools and techniques. 

The three aspects we selected (linearity, scope extrusion, coinduction) are of
course not the only ones that may cause issues in mechanisations --- but they
are fundamental to the field of concurrency theory, and they emerge in most
mechanisations.  Moreover, the mechanisations of novel research results often
requires addressing more than just one of these aspects at once --- and we see
the combination of techniques as a next step beyond the scope of this challenge
(we discuss the topic in \cref{sec:going-beyond}).

% Our challenge problems are designed to stimulate progress on answering these questions by providing simple environments in which to demonstrate, evaluate, and compare the many tools and techniques available.
% While the challenge problems themselves are thus not of scientific interest, we expect that the best practices and mechanisations developed by solving the challenge problems will also be useful for future research.

We have begun collecting solutions to our challenge problems on our website:
%
\begin{center}
  \url{https://concurrentbenchmark.github.io/}
\end{center}
%
In the longer term, we expect to use the website for promoting best practices,
tutorials and guidelines derived from solutions to our challenge problems.
%The interested reader can find more information about the current status at:
We encourage anyone interested to try the challenge problems using their
favourite tools and techniques, and to send us their solutions.

\paragraph{Outline of this paper.}
In \cref{sec:challenge-problems} we describe in more detail the three key
aspects of our challenge problems.  We discuss our design choices in
\cref{sec:design-discussion}, and possible extensions and further topics in
\cref{sec:going-beyond}.  We conclude in \cref{sec:conclusion}.
The full challenge problems, including proofs, are available in \cref{app:challenges}.

\section{The challenge problems}\label{sec:challenge-problems}
In this section we will briefly describe our three challenge problems, referring to the appendix for the full text of each challenge.

\subsection{Linearity}
Our \textbf{linearity challenge} (Appendix~\ref{sec:challenge:linearity-beh-types}) is to prove type preservation (also known as subject reduction) for a process calculus with a session type system.
Session type systems require linear handling of typing contexts, and the proof involves reasoning about the linearity of context splitting operations.
In name passing systems, scope extrusion is the expansion of the scope of a name when the name is sent outside of its original scope.

\subsection{Scope extrusion}
Our \textbf{scope extrusion challenge} (Appendix~\ref{sec:challenge:name-passing-scope-extrusion}) is to prove that barbed bisimulation is an equivalence relation for an untyped name passing calculus without infinite behaviour, but with non-deterministic choice.
The proof involves reasoning about names that are ``in the process'' of being scope extruded, which presents issues for some approaches to mechanising binders.

\subsection{Coinduction}
Our \textbf{coinduction challenge} (Appendix~\ref{sec:challenge:coinduction}) is to prove that strong barbed congruence acts like a congruence for an untyped calculus of communicating systems with (infinite) replication of processes.
The proof involves reasoning coinductively about the infinite behaviours of the replication operator.
We invite anyone interested to send us solutions to the challenge problems and to publish experience reports detailing the advantages and disadvantages of their approaches.

\section{Design of the benchmark}\label{sec:design-discussion}
\subsection{General}
- Why are the challenges not covered by POPLMark/POPLMark Reloaded?
- Choice in general
  - Choice can be encoded, so is not necessary
  - Complicates the theory
  - Add as ``future work''
- Extension categories: other topics and small technical differences
- Why not unified syntax?
  - Choice and coinduction does not mix
- A goal is to build a culture of formalising things in the community
- Encoding techniques are not different from any other field, so there's nothing ``special'' about the formalisations here

\subsection{Linearity}
- Linearity type system dual vs. Vasco's?
- Only linear channels or also unrestricted channels?
- Pi-calculus or CCS for linearity?
- Linearity: the context is polymorphic
- Linearity is generally interesting
- Why explicitly bind two endpoints in linearity? To make the duality/polarity connection obvious
- Linearity: Do we care about avoiding deadlocks? No, this is stronger than safety as in well-formedness
- Asynchrony? Not necessary, this is a it more advanced

\subsection{Scope extrusion}
- Choice in scope extrusion
- Scope extrusion does not behave as ``normal'' a binder wrt. semantics, so the usual techniques may not work
- Why do we keep the restrictions around in the LTS semantics in scope extrusion?

\subsection{Coinduction}
- Different notions of bisimulation in the coinduction challenge
- Coinduction: why is congruence interesting?
- We don't care about the content of messages in coinduction, only synchronization
- ``Proper'' barbs with a structural congruence in coinduction instead of LTS semantics

\subsection{Evaluation criteria}
We have identified three key aspects fundamental to mechanisations of concurrent calculi and designed our challenge problems to exercise these.
Like previous benchmark authors, we would like to stress that our challenge is not meant to be comprehensive: applications such as multiparty session types, choreographies, conversation types and psi-calculi are not directly covered by our challenge problems.
Most applications will however still need the basic techniques that our challenge problems exercise.
We have designed our challenge problems to exercise the three aspects independently, and they can be solved individually and in any order.
We have designed each problem to be small and easy to understand with basic knowledge of textbook concurrency theory, process calculi and type theory.
Solutions to our challenge problems should be compared on three measures: the mechanisation overhead, this being the amount of manually written infrastructure and setup needed to express the definitions in the mechanisation; the adequacy of the formal statements in the mechanisation, i.e.\ whether the proven theorems are easily recognisable as the theorems from the challenge; and the cost of entry for the tools and techniques employed, i.e.\ the difficulty of learning to use the techniques.
Solutions to our challenges do not need to strictly follow the definitions and lemmas set out in the problem text, but solutions which deviate from the original challenges will need to present more elaborate argumentation for their adequacy.


\section{Going beyond the challenge problems}\label{sec:going-beyond}

As with the challenges that came before, this one is intended to be
useful on its own, but not to cover every problem that may be faced
when mechanising systems based on message passing calculi. The current
challenge can be extended in two dimensions: the first, about taking
the existing challenges further. And the second, about devising
challenges not covered by the current benchmarks.

The proposed challenges try to minimise the overlap of the techniques
they exercise, however, most systems will combine some or all aspects
of the challenges. An interesting second round of formalisations could
entail combining the features of the challenges. In the following
table we consider the following three additions: First the addition of
choice to the type level and the process level. Second, the addition
of recursion (and recursion types for typed systems). And finally, the
addition of channel delegation to those calculi that do not already
support it.

The following table shows which extension should be suitable (that we
mark with $+$) for each challenge:

\vspace{.5em}

\begin{center}\small
  \begin{tabular}{|r|c|c|c|}
    \hline
    & Linearity & \shortstack{Scope \\ extrusion} & Coinduction \\
    \hline
    Choice & $+$ & $+$  & $+$ \\
    \hline
    \shortstack{Recursive \\ types} & $+$  & $+$ & \\
    \hline
    Delegation & $+$ & & $+$ \\
    \hline
  \end{tabular}
\end{center}

\vspace{.5em}

The other dimension to extend these calculi corresponds to systems
that are not covered by our challenges. Extending in this dimension
means proposing new challenges to cover for different features of
message passing calculi, or to cover different features of mechanised
proof.

Some interesting aspects of message passing calculi to explore in
further challenges could be: Multiparty session types, and
choreographies because their definitions and meta-theory have elements
that we do not cover here, however the elements that we do cover will
appear in these problems. Also, while we explore a form of barbed
bisimilarity one could easily design a challenge exploring different
notions of bisimilarity (barbed, or weak, etc.), and trace
equivalence.

On the side of proof assistants, the current challenge proposes
mechanising the proofs of theorems. An interesting venue to explore
would be to take advantage of other aspects of proof assistants. For
example, proof assistants are often able to produce certified code (by
using code extraction, or compiling and running their definitions).
Additionally, while having effective automation in our current
challenge is possible, a challenge could be designed with the explicit
objective of automating aspects of the proofs. And finally, a
challenge could propose the integration with other formal reasoning
tools, namely model checkers. These tools are in common use in the
field. However, there combining automated proofs with proof assistants
could be a great path for attempting larger proofs with less effort.

Ultimately, the current challenge can be extended in several
worthwhile directions, and we look forward to a future when they
indeed are extended. Moreover, we see the current challenge as setting
the foundation for those future extensions. It is our expectation that
the solutions of those hypothetical challenges will build on solutions
to this challenge.

\section{Conclusion}\label{sec:conclusion}

\subsubsection*{Acknowledgements}

\appendix
\section{Challenges}\label{app:challenges}
\input{../challenges/challenges.tex}

\bibliographystyle{splncs04}
\bibliography{../references}

\end{document}
