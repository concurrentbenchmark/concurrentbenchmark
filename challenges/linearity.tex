\subsection{Challenge: Linearity and behavioral type systems}
\label{sec:challenge:linearity-beh-types}
This challenge formalises a proof that requires reasoning about linearity of channels.
Linearity is the notion that a channel must be used exactly once in a process.
This is necessary to prove properties about session type systems.
Linear reasoning is also necessary to formalise e.g.\ linear and affine types for the pi-calculus and cut elimination in linear logics.

The setting for this challenge is a small calculus with a session type
system, the syntax and semantics of which are given below. The
calculus is a fragment of the one presented in~\cite{Vasconcelos2012},
formulated in the dual style of~\cite{barber96tr}.

The objective of this challenge is to prove type preservation (also
known as subject reduction) for the type system, i.e.\ that well-typed
processes can only transition to processes which are also well-typed
in the same context.

\subsubsection{Syntax}
The syntax is given by the grammar:
\[
\begin{array}{rcl}
  v,w & ::= & a \mid l \\
   P,Q & ::=& \Pend \mid \Pout{x}{v}{P} \mid \Pin{x}{l}{P} \mid \PBpar{P}{Q} \mid  \Presd{x}{y}{P}
\end{array}
\]
A \emph{value} \( v, w, \dots \) is either a base value \( a \) or a variable name \( l \).

The output process \( \Pout{x}{v}{P} \) can send the value \( v \) via \( x \), then continue as \( P \).
The intention is that the value \( v \) must be a base value when it is actually sent, and this will be enforced in the semantics later on.
The input process \( \Pin{x}{l}{P} \) is an \emph{input}, which can receive a base value via \( x \), then continue as \( P \) with the received value substituted for the variable name \( l \).

The process \( \Presd{x}{y}{P} \) is the \emph{restriction} of the channel with endpoints named \( x \) and \( y \) to \( P \).
Components in \( P \) can use the names \( x \) and \( y \) to interact with each other (sending on \( x \) and receiving on \( y \) or vice versa), but not with processes outside of the restriction.
The restriction operator thus binds the names \( x \) and \( y \) in \( P \).
Note that the scope of a restriction may not change when processes interact, since it is only possible to send and receive values, and not names.
Note that there is no recursion of replication in the syntax, and thus no infinite behaviors can be expressed.

\subsubsection{Semantics}
We describe the actions that the system can perform using a small step operational semantics.
To simplify the definition of the reduction relation, we will  factor out a \emph{structural congruence} relation on processes, namely  the smallest congruence relation that satisfies the following axioms:
\begin{mathpar}
  \inferrule[Sc-Par-Comm]{ }{\scong{\Ppar{P}{Q}}{\Ppar{Q}{P}}}
  \and
  \inferrule[Sc-Par-Assoc]{ }{\scong{\Ppar{(\Ppar{P}{Q})}{R}}{\Ppar{P}{(\Ppar{Q}{R})}}}
  \and
  \inferrule[Sc-Par-Inact]{ }{\scong{\Ppar{P}{\Pend}}{P}}
  \and
  \inferrule[Sc-Res-Par]{\{x,y\} \cap \freenames{Q} = \emptyset}{\scong{\Ppar{\Presd{x}{y}{P}}{Q}}{\Presd{x}{y}{(\Ppar{P}{Q})}}}
  \and
  \inferrule[Sc-Res-Inact]{ }{\scong{\Presd{x}{y}{\Pend}}{\Pend}}
  \and
  \inferrule[Sc-Res]{ }{\scong{\Presd{x_1}{y_1}{\Presd{x_2}{y_2}{P}}}{\Presd{x_2}{y_2}{\Presd{x_1}{y_1}{P}}}}
\end{mathpar}

The operational semantics is then defined as the following binary relation on processes:
\begin{mathpar}
  \inferrule[R-Com]{ }{\reduces{\Presd{x}{y}{(\Ppar{\Pout{x}{a}{P}}{\Ppar{\Pin{y}{l}{Q}}{R}})}}{\Presd{x}{y}{(\Ppar{P}{\Ppar{\subst{Q}{a}{l}}{R}})}}}
  \and
  \inferrule[R-Res]{\reduces{P}{Q}}{\reduces{\Presd{x}{y}{P}}{\Presd{x}{y}{Q}}}
  \and
  \inferrule[R-Par]{\reduces{P}{Q}}{\reduces{\Ppar{P}{R}}{\Ppar{Q}{R}}}
  \and
  \inferrule[R-Struct]{\scong{P}{P'} \\ \reduces{P'}{Q'} \\ \scong{Q}{Q'}}{\reduces{P}{Q}}
\end{mathpar}
Note that there is no rule for inferring an action of an input or output process except those that match the input/output capability.
Note also that due to rule \TirName{R-Com}, the process \( \Pin{y}{l}{P} \) can receive \emph{any} base value.
On the other hand, since the rule \TirName{R-Com} only applies to sending base values, there is no way to send a variable name or a name.

\subsubsection{Session types}
Our process syntax allows us to write processes that are not well-formed in the sense that they either use the endpoints bound by a restriction to communicate in a way that does not follow the intended duality of communication, or attempt to send something which is not a base value.
As an example, the following process attempts to send a base value on both \( x \) and \( y\), whereas the intention of restricting names is that one of the names is used for sending and the other for receiving: \( \Presd{x}{y}{(\Ppar{\Pout{x}{a}{\Pend}}{\Pout{y}{a}{\Pend}})} \).
Another example is the following process, which attempts to send a variable that is not instantiated at the time of sending: \( \Presd{x}{y}{(\Ppar{\Pout{x}{l}{\Pend}}{\Pin{y}{l}{\Pend}})} \).

To alleviate this issue, we introduce a \emph{session type system}, which will detect processes that are not well-formed.

\paragraph{Syntax}
Our type system does not type processes directly, but instead focuses on the channels used in the process.
The syntax of \emph{session types} \( S, T \), unrestricted type contexts \( \Gamma \) and linear type contexts \( \Delta \) is as follows:
\[
  \begin{array}{rcl}
  S,T & ::= & \Tend \mid \Tbase \mid \Tin{S} \mid \Tout{S} \\
    \Gamma &::= & \Cempty \mid \Gamma, l \\
                    \Delta &::= & \Cempty \mid \Cadd{\Delta}{\hastype{x}{S}}
  \end{array}
\]
The \emph{end type}, \( \Tend \), is the type of an endpoint on which no further interaction is possible.
The \emph{base type}, \( \Tbase \), is the type of base values.
The \emph{input type}, \( \Tin{S} \), is the type of an endpoint which is ready to receive a value, then continue with type \( S \).
The \emph{output type}, \( \Tout{S} \), is the type of an endpoint which is ready to send a value, then continue with type \( S \).

Typing contexts gather type information about names and variables.
We distinguish between an unrestricted context $\Gamma$ seen as a set: since  we have only one base type, we only record which variable names have been used.
Type information for endpoints is captured in the \emph{linear}
context \( \Delta \). We use the comma as split/union, overloaded to
singletons, and \( \Cempty \) is the empty multiset.
We extend the Barendregt convention to contexts, so that all entries
are distinct.  Note that the order in which information is added to a
type context thus does not matter.

Since we need to determine whether endpoints are used dually to determine whether processes are well-formed, we will need to formally define the dual of a type.
The dual of a type, \( \dual{T} \), is defined by the following equations:
\begin{mathpar}
  \inferrule{}{\dual{\Tin{S}} = \Tout{\dual{S}}}
  \and
  \inferrule{}{\dual{\Tout{S}} = \Tin{\dual{S}}}
  \and
  \inferrule{}{\dual{\Tend} = \Tend}
\end{mathpar}
Note that the dual function is not total, since it is not defined for the base type.

\subsubsection{Typing rules}
Our type system will maintain two invariants:
\begin{enumerate}
\item Endpoints are used exactly once
\item Endpoints that are part of the same restriction have dual types
\end{enumerate}
The first invariant is maintained by linearly splitting type contexts when typing compositions of processes.
The second invariant is maintained by requiring duality when typing restrictions.

We have three typing judgments: one for values, one for names, and one for processes.
The typing rules for values are as follows:
\begin{mathpar}
  \inferrule[T-Base]{ }{\typev{\Gamma}{\hastype{a}{\Tbase}}} \and
  \inferrule[T-Var]{ }{\typev{\Cadd{\Gamma}l }{\hastype{l}{\Tbase}}}
\end{mathpar}
The typing rule for names is as follows, where $\tend \Phi$ denotes that all types in the range of $\Phi$ are $\Tend$:
\begin{mathpar}
  \inferrule[T-Name]{{\tend\Delta }}{\types{{\Gamma; (\Delta,\hastype{x}{T})}}{\hastype{x}{T}}}
\end{mathpar}
The typing rules for processes are as follows:
\begin{mathpar}

  \inferrule[T-Inact]{\tend\Delta }{\types{\Gamma;\Delta}{\Pend}}
  \and
  \inferrule[T-Par]{\types{\Gamma;\Delta_1}{P} \\ \types{\Gamma;\Delta_2}{Q}}
  {\types{\Gamma; \Csplit{\Delta_1}{\Delta_2}}{\Ppar{P}{Q}}}
  \and
  \inferrule[T-Res]{\types{\Gamma; (\Cadd{\Cadd{\Delta}{\hastype{x}{T}}}{\hastype{y}{\dual{T}}}}{P})}{\types{\Gamma}{\Presd{x}{y}{P}}}
  \and
    \inferrule[T-Out]{
      \typev{\Gamma}{\hastype{v}{\Tbase}} \\ \types{\Gamma; \Cupdate{\Delta}{\hastype{x}{T}}}{P}}{\types{\Gamma; (\Csplit{\Delta}{\hastype{x}{\Tout{T}}})}{\Pout{x}{v}{P}}}
    \and
    \inferrule[T-IN]{
      \types{(\Gamma,  l ); (\Cupdate{\Delta}{\hastype{x}{T}})}{P}}{\types{\Gamma; (\Csplit{\Delta}{\hastype{x}{\Tin{T}}})}{\Pin{x}{l}{P}}}
\end{mathpar}

\subsubsection{Challenge}
The objective of this challenge is to prove subject reduction and type safety for our calculus with session types. We start with:
\begin{theorem}[Subject reduction]
  If \( \types{\Gamma;\Delta}{P} \) and \( \reduces{P}{Q} \) then \( \types{\Gamma;\Delta}{Q} \).
\end{theorem}
\begin{proof}
  Induction on the reduction relation, TBD.
\end{proof}

The following lemmas may be of use:
\begin{lemma}[Weakening]\mbox{}
  \label{lemma:weak}
  \begin{enumerate}
  \item If \( \types{\Gamma; \Delta}{P} \) then
    \( \types{\Cadd{\Gamma}{l};\Delta}{P} \).
      \item If \( \types{\Gamma; \Delta}{P} \) and \( \tend{\Delta} \) then
    \( \types{\Gamma;\Cadd{\Delta}{\hastype{x}{T}}}{P} \).
\end{enumerate}
\end{lemma}
\begin{proof}
  By induction on the given derivations.
\end{proof}
\begin{lemma}[Strengthening]\mbox{}
  \label{lemma:strenD}
  If \( \types{\Gamma; \Delta, z : T}{P} \) and $z\not\in \freenames{P}$, then \( \types{\Gamma; \Delta}{P} \).
\end{lemma}
\begin{proof}
  By induction on the given derivation.
\end{proof}

\begin{lemma}[Substitution]\mbox{}
  If $\types{(\Gamma, l);\Delta}{P}$ and ${\typev{\Gamma}{\hastype{a}{\Tbase}}}$ then
  \( \types{\Gamma;\Delta}{\subst{P}{l}{a}} \).
\end{lemma}
\begin{proof}
  By induction on the first derivation.
\end{proof}
\begin{lemma}[Preservation for $\equiv$]
  If \( \types{\Gamma;\Delta}{P} \) and \( \scong{P}{Q} \) then \( \types{\Gamma;\Delta}{Q} \).
\end{lemma}
\begin{proof}
  By induction on the structure of a process context. In the base case, proceed by case analysis on the \textsl{Sc} rule applied:
  \begin{description}
  \item[Res:] use weakening~\ref{lemma:weak} part 2
  \item[Comm/Assoc:] by rearranging sub-derivations noting that  order does not matter for linear context
  \item[Inact] Left-to-right by
    strengthening~\ref{lemma:strenD}. Vice-versa, by weakening~\ref{lemma:weak} part 2.
  \item[Res-Par] Follows Vasco's proof by case analysis on $x : T$ being linear and applying weak and stren accordingly.
  \item[Res] order does not matter
  \end{description}
  For the step case, TBD
\end{proof}

To formulate safety, we need to formally define what we mean by well-formed.
We say that a process \( P \) is \emph{prefixed at variable \( x \)} if it is of the form \( \Pout{x}{v}{P} \) or \( \Pin{x}{l}{P} \).
A process is then \emph{well-formed} if, for each of its structurally congruent processes of the form \( \Presd{x_1}{y_1}{\dots \Presd{x_n}{y_n}{(\Ppar{\Ppar{P}{Q}}{R})}} \), with \( n \geq 0 \), it holds that, if \( P \) is prefixed at \( x_1 \) and \( Q \) is prefixed at \( y_1 \), then \( \Ppar{P}{Q} \) is of the form \( \Ppar{\Pout{x_1}{a}{P'}}{\Pin{y_1}{l}{Q'}} \).

Note that well-formed processes do not necessarily reduce, since e.g.\ the process
\begin{equation*}
  \Presd{x_1}{y_1}{\Presd{x_2}{y_2}{(\Ppar{\Pout{x_1}{a}{\Pin{y_2}{l}{\Pend}}}{\Pout{y_2}{x_2}{\Pin{y_1}{l}{\Pend}}})}}
\end{equation*}
is well-formed, but has no reduction.


\begin{theorem}[Type safety]
  If \( \types{\Cempty}{P} \), then \( P \) is well-formed.
\end{theorem}

\begin{corollary}
  If \( \types{\Cempty}{P} \) and \( \reduces{P}{Q} \) then \( Q \) is well-formed.
\end{corollary}