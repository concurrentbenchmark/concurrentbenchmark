\subsection{Challenge: Linearity and behavioral type systems}
\label{sec:challenge:linearity-beh-types}
This challenge formalises a proof that requires reasoning about linearity of channels.
Linearity is the notion that a channel must be used exactly once in a process.
This is necessary to prove properties about session type systems.
Linear reasoning is also necessary to formalise e.g.\ linear and affine types for the pi-calculus and cut elimination in linear logics.

The setting for this challenge is a small calculus with a session type
system, the syntax and semantics of which are given below. The
calculus is a fragment of the one presented in~\cite{Vasconcelos2012},
formulated in the dual style of~\cite{barber96tr}.

The main objective of this challenge is to prove type preservation (also
known as subject reduction), i.e.\ that well-typed
processes can only transition to processes which are also well-typed
in the same context.
The second objective is to prove type safety, i.e.\ that well-typed processes are also well-formed in the sense that they do not use endpoints in a non-dual way.

\subsubsection{Syntax.}
The syntax is given by the grammar
\[
\begin{array}{rcl}
  v,w & ::= & a \quad\mid\quad l \\
   P,Q & ::=& \Pend \quad\mid\quad \Pout{x}{v}{P} \quad\mid\quad \Pin{x}{l}{P} \quad\mid\quad \PBpar{P}{Q} \quad\mid\quad  \Presd{x}{y}{P}
\end{array}
\]
where a \emph{value} \( v, w, \dots \) is either a base value \( a \) or a variable name \( l \).

The output process \( \Pout{x}{v}{P} \) sends the value \( v \) via \( x \) and then continues as \( P \).
The intention is that the value \( v \) must be a base value when it is actually sent, and this will be enforced in the semantics later on.
The input process \( \Pin{x}{l}{P} \) waits for a base value from \( x \) and then continues as \( P \) with the received value substituted for the variable name \( l \).
%
The process \( \Presd{x}{y}{P} \) represents a \emph{session} with endpoints named \( x \) and \( y \) which are bound in \( P \). In \( P \), the names \( x \) and \( y \) can be used to exchange messages over the session (sending on \( x \) and receiving on \( y \) or vice versa).
%
%Finally, the process $\PBpar{P}{Q}$ represents the parallel composition of $P$ and $Q$.
%
Note that in this calculus channels cannot be sent in messages, therefore the topology of the communication network described by a process cannot change.
Also, there is no recursion or replication in the syntax, hence no infinite behaviors can be expressed. In particular, we only model linear (as opposed to shared) channels.

\subsubsection{Semantics.}
We describe the actions that the system can perform through a small step operational semantics.
As usual, we use  a \emph{structural congruence} relation that equates processes that we deem to be indistinguishable. Structural congruence is the smallest congruence relation that satisfies the following axioms:
\begin{mathpar}
  \inferrule[Sc-Par-Comm]{ }{\scong{\Ppar{P}{Q}}{\Ppar{Q}{P}}}
  \and
  \inferrule[Sc-Par-Assoc]{ }{\scong{\Ppar{(\Ppar{P}{Q})}{R}}{\Ppar{P}{(\Ppar{Q}{R})}}}
  \and
  \inferrule[Sc-Par-Inact]{ }{\scong{\Ppar{P}{\Pend}}{P}}
  \and
  \inferrule[Sc-Res-Par]{\{x,y\} \cap \freenames{Q} = \emptyset}{\scong{\Ppar{\Presd{x}{y}{P}}{Q}}{\Presd{x}{y}{(\Ppar{P}{Q})}}}
  \and
  \inferrule[Sc-Res-Inact]{ }{\scong{\Presd{x}{y}{\Pend}}{\Pend}}
  \and
  \inferrule[Sc-Res]{ }{\scong{\Presd{x_1}{y_1}{\Presd{x_2}{y_2}{P}}}{\Presd{x_2}{y_2}{\Presd{x_1}{y_1}{P}}}}
\end{mathpar}

The operational semantics is then defined as the following binary relation on processes:
\begin{mathpar}
  \inferrule[R-Com]{ }{\reduces{\Presd{x}{y}{(\Ppar{\Pout{x}{a}{P}}{\Ppar{\Pin{y}{l}{Q}}{R}})}}{\Presd{x}{y}{(\Ppar{P}{\Ppar{\subst{Q}{a}{l}}{R}})}}}
  \and
  \inferrule[R-Res]{\reduces{P}{Q}}{\reduces{\Presd{x}{y}{P}}{\Presd{x}{y}{Q}}}
  \and
  \inferrule[R-Par]{\reduces{P}{Q}}{\reduces{\Ppar{P}{R}}{\Ppar{Q}{R}}}
  \and
  \inferrule[R-Struct]{\scong{P}{P'} \\ \reduces{P'}{Q'} \\ \scong{Q}{Q'}}{\reduces{P}{Q}}
\end{mathpar}

Note that reductions are allowed only for restricted pairs of session endpoints. This makes it possible to formulate subject reduction so that the typing context is exactly the same before and after each reduction.
%
Note also that due to rule \TirName{R-Com}, the process \( \Pin{y}{l}{P} \) can receive \emph{any} base value.
On the other hand, since the rule \TirName{R-Com} only applies to sending base values, there is no way to send a variable name or a name.

\subsubsection{Session types.}
Our process syntax allows us to write processes that are ill formed in
the sense that they either use the endpoints bound by a restriction to
communicate in a way that does not follow the intended duality, or
attempt to send something which is not a base value.  As an example,
the process
\( \Presd{x}{y}{(\Ppar{\Pout{x}{a}{\Pend}}{\Pout{y}{a}{\Pend}})} \)
attempts to send a base value on both \( x \) and \( y\), whereas one
of the names should be used for receiving in order to guarantee
progress.  Another example is the process
\( \Presd{x}{y}{(\Ppar{\Pout{x}{l}{\Pend}}{\Pin{y}{l}{\Pend}})} \),
which attempts to send a variable that is not instantiated at the time
of sending.
%
To prevent these issues, we introduce a \emph{session type system} which
rules out ill-formed processes.

\paragraph{Syntax}
Our type system does not type processes directly, but instead focuses on the channels used in the process.
The syntax of \emph{session types} \( S, T \), unrestricted type contexts \( \Gamma \) and linear type contexts \( \Delta \) is as follows:
\[
  \begin{array}{rcl}
  S,T & ::= & \Tend \quad\mid\quad \Tbase \quad\mid\quad \Tin{S} \quad\mid\quad \Tout{S} \\
    \Gamma &::= & \Cempty \quad\mid\quad \Gamma, l \\
                    \Delta &::= & \Cempty \quad\mid\quad \Cadd{\Delta}{\hastype{x}{S}}
  \end{array}
\]
The \emph{end type} \( \Tend \) describes an endpoint on which no further interaction is possible.
The \emph{base type} \( \Tbase \) describes base values.
The \emph{input type} \( \Tin{S} \) describes endpoints used for receiving a value and then according to \( S \).
The \emph{output type} \( \Tout{S} \) describes endpoints used for sending a value and then according to \( S \).

Typing contexts gather type information about names and variables.
\emph{Unrestricted} contexts are simply sets of names since we only have one
base type. \emph{Linear contexts} associate a type to endpoints. We use
the comma as split/union, overloaded to singletons, and \( \Cempty \) as the
empty context. We extend the Barendregt convention to contexts, so that all
entries are distinct.  Note that the order in which information is added to a
type context does not matter.

Since we need to determine whether endpoints are used in complementary ways to determine whether processes are well formed, we need to formally define the dual of a type as follows:
\begin{mathpar}
  \inferrule{}{\dual{\Tin{S}} = \Tout{\dual{S}}}
  \and
  \inferrule{}{\dual{\Tout{S}} = \Tin{\dual{S}}}
  \and
  \inferrule{}{\dual{\Tend} = \Tend}
\end{mathpar}
Note that the dual function is partial since it is undefined for the base type.

\subsubsection{Typing rules}
Our type system is aimed at maintaining two invariants:
\begin{enumerate}
\item No endpoint is used simultaneously by parallel processes;
\item The two endpoints of the same session have dual types.
\end{enumerate}
The first invariant is maintained by linearly splitting type contexts when typing compositions of processes, the second by requiring duality when typing restrictions.

We have two typing judgments: one for values, and one for processes.
The typing rules for values are:
\begin{mathpar}
  \inferrule[T-Base]{ }{\typev{\Gamma}{\hastype{a}{\Tbase}}} \and
  \inferrule[T-Var]{ }{\typev{\Cadd{\Gamma}l }{\hastype{l}{\Tbase}}}
\end{mathpar}
% In the typing rule for names, $\tend \Phi$ denotes that all types in the range of $\Phi$ are $\Tend$:
% \begin{mathpar}
%   \inferrule[T-Name]{{\tend\Delta }}{\types{{\Gamma; (\Delta,\hastype{x}{T})}}{\hastype{x}{T}}}
% \end{mathpar}
The typing rules for processes are as follows:
\begin{mathpar}

  \inferrule[T-Inact]{\tend\Delta }{\types{\Gamma;\Delta}{\Pend}}
  \and
  \inferrule[T-Par]{\types{\Gamma;\Delta_1}{P} \\ \types{\Gamma;\Delta_2}{Q}}
  {\types{\Gamma; \Csplit{\Delta_1}{\Delta_2}}{\Ppar{P}{Q}}}
  \and
  \inferrule[T-Res]{\types{\Gamma; (\Cadd{\Cadd{\Delta}{\hastype{x}{T}}}{\hastype{y}{\dual{T}}}}{P})}{\types{\Gamma}{\Presd{x}{y}{P}}}
  \and
    \inferrule[T-Out]{
      \typev{\Gamma}{\hastype{v}{\Tbase}} \\ \types{\Gamma; \Cupdate{\Delta}{\hastype{x}{T}}}{P}}{\types{\Gamma; (\Csplit{\Delta}{\hastype{x}{\Tout{T}}})}{\Pout{x}{v}{P}}}
    \and
    \inferrule[T-IN]{
      \types{(\Gamma,  l ); (\Cupdate{\Delta}{\hastype{x}{T}})}{P}}{\types{\Gamma; (\Csplit{\Delta}{\hastype{x}{\Tin{T}}})}{\Pin{x}{l}{P}}}
\end{mathpar}
Note that we do not need a judgment for typing channels, since it is already folded into the T-IN and T-OUT rules.

\subsubsection{Challenge}
The objective of this challenge is to prove subject reduction and type safety for our calculus with session types. We start with:
\begin{theorem}[Subject reduction]
  If \( \types{\Gamma;\Delta}{P} \) and \( \reduces{P}{Q} \) then \( \types{\Gamma;\Delta}{Q} \).
\end{theorem}
\begin{proof}
  By induction on the derivation of $\reduces{P}{Q}$. TBD
\end{proof}

The following lemmas are needed:
\begin{lemma}[Weakening]\mbox{}
  \label{lemma:weak}
  \begin{enumerate}
  \item If \( \types{\Gamma; \Delta}{P} \) then
    \( \types{(\Cadd{\Gamma}{l});\Delta}{P} \).
      \item If \( \types{\Gamma; \Delta}{P} \) and \( \tend{\Delta} \) then
    \( \types{\Gamma;(\Cadd{\Delta}{\hastype{x}{\Tend}})}{P} \).
  \end{enumerate}
  % \begin{metanote}
  %   Note from Dawit: Does \( \Delta \) really have to be only ends to be weakened? I had expected that if \( P \) is typed by \( \Delta \) and \( \Delta' \) is only ends, then \( P \) is typed by \( \Cadd{\Delta}{\Delta'} \).
    
  %   AM:  I agree that it's weird: we should not be able to weaken a linear context, if not
  %   with unrestricted types --- but this is what we need for Sc-Res-Inact to be type preserving:
  %   from $\Delta\vdash 0$ we need $\Delta\vdash (\nu x y)0$. BTW, this is also a problem in Vasco's system 
  % \end{metanote}
\end{lemma}
\begin{proof}
  By induction on the given derivations.
\end{proof}
\begin{lemma}[Strengthening]\mbox{}
  \label{lemma:strenD}
  If \( \types{\Gamma; (\Delta, x : T)}{P} \) and $x\not\in \freenames{P}$, then \( \types{\Gamma; \Delta}{P} \).
\end{lemma}
\begin{proof}
  By induction on the given derivation.
\end{proof}

\begin{lemma}[Substitution]\mbox{}
  If $\types{(\Gamma, l);\Delta}{P}$ and ${\typev{\Gamma}{\hastype{a}{\Tbase}}}$ then
  \( \types{\Gamma;\Delta}{\subst{P}{l}{a}} \).
\end{lemma}
\begin{proof}
  By induction on the first derivation.
\end{proof}
\begin{lemma}[Preservation for $\equiv$]
  If \( \types{\Gamma;\Delta}{P} \) and \( \scong{P}{Q} \) then \( \types{\Gamma;\Delta}{Q} \).
\end{lemma}
\begin{proof}
  By induction on the structure of a process context involved in the congruence. In the base case where the context is a hole, proceed by case analysis on the \textsl{Sc} rule applied:
  \begin{description}
  \item[Par-Comm/Assoc:] by rearranging sub-derivations noting that
    order does not matter for linear contexts
  \item[Par-Inact] right-to-left by
    strengthening~\ref{lemma:strenD}. Vice-versa, by picking $T$ to be $\Tend$ and weakening~\ref{lemma:weak} part 2.
  \item[Res-Par] Follows Vasco's proof by case analysis on $x : T$ being linear and applying weak and stren accordingly.
  \item[Res-Inact:] use weakening~\ref{lemma:weak} part 2
  \item[Res] order does not matter
  \end{description}
  For the step case, TBD
\end{proof}

To formulate safety, we need to formally define what we mean by well-formed process.
We say that a process \( P \) is \emph{prefixed at variable \( x \)} if it is of the form \( \Pout{x}{v}{P} \) or \( \Pin{x}{l}{P} \).
A process is then \emph{well formed} if, for each of its structurally congruent processes of the form \( \Presd{x_1}{y_1}{\dots \Presd{x_n}{y_n}{(\Ppar{\Ppar{P}{Q}}{R})}} \), with \( n \geq 0 \), it holds that, if \( P \) is prefixed at \( x_1 \) and \( Q \) is prefixed at \( y_1 \), then \( \Ppar{P}{Q} \) is of the form \( \Ppar{\Pout{x_1}{a}{P'}}{\Pin{y_1}{l}{Q'}} \).

Note that well-formed processes do not necessarily reduce. For example, the process
\begin{equation*}
  \Presd{x_1}{y_1}{\Presd{x_2}{y_2}{(\Ppar{\Pout{x_1}{a}{\Pin{y_2}{l}{\Pend}}}{\Pout{y_2}{x_2}{\Pin{y_1}{l}{\Pend}}})}}
\end{equation*}
is well formed but also irreducible.

\begin{theorem}[Type safety]
  If \( \types{\Cempty}{P} \), then \( P \) is well formed.
\end{theorem}

\begin{corollary}
  If \( \types{\Cempty}{P} \) and \( \reduces{P}{Q} \) then \( Q \) is well formed.
\end{corollary}