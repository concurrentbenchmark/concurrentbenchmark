\subsection{Challenge: Linearity and behavioral type systems}
\label{sec:challenge:linearity-beh-types}
This challenge formalises a proof that requires reasoning about linearity of channels.
Linearity is the notion that a channel must be used exactly once in a process.
This is necessary to prove properties about session type systems.
Linear reasoning is also necessary to formalise e.g.\ linear and affine types for the pi-calculus and cut elimination in linear logics.

The setting for this challenge is a small calculus with a session type
system, the syntax and semantics of which are given below. The
calculus is a fragment of the one presented in~\cite{Vasconcelos2012},
formulated in the dual style of~\cite{barber96tr}.

The objective of this challenge is to prove type preservation (also
known as subject reduction) for the type system, i.e.\ that well-typed
processes can only transition to processes which are also well-typed
in the same context.

\subsubsection{Syntax.}
The syntax is given by the grammar
\[
\begin{array}{rcl}
  v,w & ::= & a \mid l \\
   P,Q & ::=& \Pend \mid \Pout{x}{v}{P} \mid \Pin{x}{l}{P} \mid \PBpar{P}{Q} \mid  \Presd{x}{y}{P}
\end{array}
\]
where a \emph{value} \( v, w, \dots \) is either a base value \( a \) or a variable name \( l \).

The output process \( \Pout{x}{v}{P} \) sends the value \( v \) via \( x \) and then continues as \( P \).
The intention is that the value \( v \) must be a base value when it is actually sent, and this will be enforced in the semantics later on.
The input process \( \Pin{x}{l}{P} \) waits for a base value from \( x \) and then continues as \( P \) with the received value substituted for the variable name \( l \).
%
The process \( \Presd{x}{y}{P} \) represents a \emph{session} with endpoints named \( x \) and \( y \) which are bound in \( P \). In \( P \), the names \( x \) and \( y \) can be used to exchange messages over the session (sending on \( x \) and receiving on \( y \) or vice versa).
%
Finally, the process $\PBpar{P}{Q}$ represents the parallel composition of $P$ and $Q$.
%
Note that in this calculus channels cannot be sent in messages, therefore the topology of the communication network described by a process cannot change.
Also, there is no recursion or replication in the syntax, hence no infinite behaviors can be expressed. In particular, we only model linear (as opposed to shared) channels.

\subsubsection{Semantics.}
We describe the actions that the system can perform through a small step operational semantics.
As usual, we make use of a \emph{structural congruence} relation that equates processes that we deem to be indistinguishable. Structural congruence is the smallest congruence relation that satisfies the following axioms:
\begin{mathpar}
  \inferrule[Sc-Par-Comm]{ }{\scong{\Ppar{P}{Q}}{\Ppar{Q}{P}}}
  \and
  \inferrule[Sc-Par-Assoc]{ }{\scong{\Ppar{(\Ppar{P}{Q})}{R}}{\Ppar{P}{(\Ppar{Q}{R})}}}
  \and
  \inferrule[Sc-Par-Inact]{ }{\scong{\Ppar{P}{\Pend}}{P}}
  \and
  \inferrule[Sc-Res-Par]{\{x,y\} \cap \freenames{Q} = \emptyset}{\scong{\Ppar{\Presd{x}{y}{P}}{Q}}{\Presd{x}{y}{(\Ppar{P}{Q})}}}
  \and
  \inferrule[Sc-Res-Inact]{ }{\scong{\Presd{x}{y}{\Pend}}{\Pend}}
  \and
  \inferrule[Sc-Res]{ }{\scong{\Presd{x_1}{y_1}{\Presd{x_2}{y_2}{P}}}{\Presd{x_2}{y_2}{\Presd{x_1}{y_1}{P}}}}
\end{mathpar}

The operational semantics is then defined as the following binary relation on processes:
\begin{mathpar}
  \inferrule[R-Com]{ }{\reduces{\Presd{x}{y}{(\Ppar{\Pout{x}{a}{P}}{\Ppar{\Pin{y}{l}{Q}}{R}})}}{\Presd{x}{y}{(\Ppar{P}{\Ppar{\subst{Q}{a}{l}}{R}})}}}
  \and
  \inferrule[R-Res]{\reduces{P}{Q}}{\reduces{\Presd{x}{y}{P}}{\Presd{x}{y}{Q}}}
  \and
  \inferrule[R-Par]{\reduces{P}{Q}}{\reduces{\Ppar{P}{R}}{\Ppar{Q}{R}}}
  \and
  \inferrule[R-Struct]{\scong{P}{P'} \\ \reduces{P'}{Q'} \\ \scong{Q}{Q'}}{\reduces{P}{Q}}
\end{mathpar}

Note that there is no rule for inferring an action of an input or output process except those that match the input/output capability.\luca{Unclear to me. Since it is a reduction semantics it's obvious that input/output actions alone cannot do anything. I would remove this sentence}
%
Note that reductions are allowed only for restricted pairs of session endpoints. This makes it possible to formulate subject reduction so that the typing context is exactly the same before and after each reduction.
%
Note also that due to rule \TirName{R-Com}, the process \( \Pin{y}{l}{P} \) can receive \emph{any} base value.
On the other hand, since the rule \TirName{R-Com} only applies to sending base values, there is no way to send a variable name or a name.

\subsubsection{Session types.}
Our process syntax allows us to write processes that are ill formed in the sense that they either use the endpoints bound by a restriction to communicate in a way that does not follow the intended duality of communication, or attempt to send something which is not a base value.
As an example, the process \( \Presd{x}{y}{(\Ppar{\Pout{x}{a}{\Pend}}{\Pout{y}{a}{\Pend}})} \) attempts to send a base value on both \( x \) and \( y\), whereas one of the names should be used for receiving in order to guarantee progress.
Another example is the process \( \Presd{x}{y}{(\Ppar{\Pout{x}{l}{\Pend}}{\Pin{y}{l}{\Pend}})} \), which attempts to send a variable that is not instantiated at the time of sending.
%
To prevent these issues, we introduce a \emph{session type system} which
rules out ill-formed processes.

\paragraph{Syntax}
Our type system does not type processes directly, but instead focuses on the channels used in the process.
The syntax of \emph{session types} \( S, T \), unrestricted type contexts \( \Gamma \) and linear type contexts \( \Delta \) is as follows:
\[
  \begin{array}{rcl}
  S,T & ::= & \Tend \mid \Tbase \mid \Tin{S} \mid \Tout{S} \\
    \Gamma &::= & \Cempty \mid \Gamma, l \\
                    \Delta &::= & \Cempty \mid \Cadd{\Delta}{\hastype{x}{S}}
  \end{array}
\]
The \emph{end type} \( \Tend \) describes an endpoint on which no further interaction is possible.
The \emph{base type} \( \Tbase \) describes base values.
The \emph{input type} \( \Tin{S} \) describes endpoints used for receiving a value and then according to \( S \).
The \emph{output type} \( \Tout{S} \) describes endpoints used for sending a value and then according to \( S \).

Typing contexts gather type information about names and variables.
\emph{Unrestricted} contexts are simply sets of names since we only have one
base type. \emph{Linear contexts} associate a type to endpoints. We use
the comma as split/union, overloaded to singletons, and \( \Cempty \) is the
empty multiset. We extend the Barendregt convention to contexts, so that all
entries are distinct.  Note that the order in which information is added to a
type context does not matter.

Since we need to determine whether endpoints are used in complementary ways to determine whether processes are well formed, we need to formally define the dual of a type as follows:
\begin{mathpar}
  \inferrule{}{\dual{\Tin{S}} = \Tout{\dual{S}}}
  \and
  \inferrule{}{\dual{\Tout{S}} = \Tin{\dual{S}}}
  \and
  \inferrule{}{\dual{\Tend} = \Tend}
\end{mathpar}
Note that the dual function is partial since it is undefined for the base type.

\subsubsection{Typing rules}
Our type system is aimed at maintaining two invariants:
\begin{enumerate}
\item No endpoint is used simultaneously by parallel processes;
\item The two endpoints of the same session have dual types.
\end{enumerate}
The first invariant is maintained by linearly splitting type contexts when typing compositions of processes.
The second invariant is maintained by requiring duality when typing restrictions.

We have three typing judgments: one for values, one for names, and one for processes.
The typing rules for values are as follows:
\begin{mathpar}
  \inferrule[T-Base]{ }{\typev{\Gamma}{\hastype{a}{\Tbase}}} \and
  \inferrule[T-Var]{ }{\typev{\Cadd{\Gamma}l }{\hastype{l}{\Tbase}}}
\end{mathpar}
The typing rule for names is as follows, where $\tend \Phi$ denotes that all types in the range of $\Phi$ are $\Tend$:
\begin{mathpar}
  \inferrule[T-Name]{{\tend\Delta }}{\types{{\Gamma; (\Delta,\hastype{x}{T})}}{\hastype{x}{T}}}
\end{mathpar}
The typing rules for processes are as follows:
\begin{mathpar}

  \inferrule[T-Inact]{\tend\Delta }{\types{\Gamma;\Delta}{\Pend}}
  \and
  \inferrule[T-Par]{\types{\Gamma;\Delta_1}{P} \\ \types{\Gamma;\Delta_2}{Q}}
  {\types{\Gamma; \Csplit{\Delta_1}{\Delta_2}}{\Ppar{P}{Q}}}
  \and
  \inferrule[T-Res]{\types{\Gamma; (\Cadd{\Cadd{\Delta}{\hastype{x}{T}}}{\hastype{y}{\dual{T}}}}{P})}{\types{\Gamma}{\Presd{x}{y}{P}}}
  \and
    \inferrule[T-Out]{
      \typev{\Gamma}{\hastype{v}{\Tbase}} \\ \types{\Gamma; \Cupdate{\Delta}{\hastype{x}{T}}}{P}}{\types{\Gamma; (\Csplit{\Delta}{\hastype{x}{\Tout{T}}})}{\Pout{x}{v}{P}}}
    \and
    \inferrule[T-IN]{
      \types{(\Gamma,  l ); (\Cupdate{\Delta}{\hastype{x}{T}})}{P}}{\types{\Gamma; (\Csplit{\Delta}{\hastype{x}{\Tin{T}}})}{\Pin{x}{l}{P}}}
\end{mathpar}

\subsubsection{Challenge}
The objective of this challenge is to prove subject reduction and type safety for our calculus with session types. We start with:
\begin{theorem}[Subject reduction]
  If \( \types{\Gamma;\Delta}{P} \) and \( \reduces{P}{Q} \) then \( \types{\Gamma;\Delta}{Q} \).
\end{theorem}
\begin{proof}
  By induction on the derivation of $\reduces{P}{Q}$. TBD
\end{proof}

The following lemmas may be of use:
\begin{lemma}[Weakening]\mbox{}
  \label{lemma:weak}
  \begin{enumerate}
  \item If \( \types{\Gamma; \Delta}{P} \) then
    \( \types{\Cadd{\Gamma}{l};\Delta}{P} \).
      \item If \( \types{\Gamma; \Delta}{P} \) and \( \tend{\Delta} \) then
    \( \types{\Gamma;\Cadd{\Delta}{\hastype{x}{T}}}{P} \).
\end{enumerate}
\end{lemma}
\begin{proof}
  By induction on the given derivations.
\end{proof}
\begin{lemma}[Strengthening]\mbox{}
  \label{lemma:strenD}
  If \( \types{\Gamma; \Delta, z : T}{P} \) and $z\not\in \freenames{P}$, then \( \types{\Gamma; \Delta}{P} \).
\end{lemma}
\begin{proof}
  By induction on the given derivation.
\end{proof}

\begin{lemma}[Substitution]\mbox{}
  If $\types{(\Gamma, l);\Delta}{P}$ and ${\typev{\Gamma}{\hastype{a}{\Tbase}}}$ then
  \( \types{\Gamma;\Delta}{\subst{P}{l}{a}} \).
\end{lemma}
\begin{proof}
  By induction on the first derivation.
\end{proof}
\begin{lemma}[Preservation for $\equiv$]
  If \( \types{\Gamma;\Delta}{P} \) and \( \scong{P}{Q} \) then \( \types{\Gamma;\Delta}{Q} \).
\end{lemma}
\begin{proof}
  By induction on the structure of a process context. In the base case, proceed by case analysis on the \textsl{Sc} rule applied:
  \begin{description}
  \item[Res:] use weakening~\ref{lemma:weak} part 2
  \item[Comm/Assoc:] by rearranging sub-derivations noting that  order does not matter for linear context
  \item[Inact] Left-to-right by
    strengthening~\ref{lemma:strenD}. Vice-versa, by weakening~\ref{lemma:weak} part 2.
  \item[Res-Par] Follows Vasco's proof by case analysis on $x : T$ being linear and applying weak and stren accordingly.
  \item[Res] order does not matter
  \end{description}
  For the step case, TBD
\end{proof}

To formulate safety, we need to formally define what we mean by well-formed process.
We say that a process \( P \) is \emph{prefixed at variable \( x \)} if it is of the form \( \Pout{x}{v}{P} \) or \( \Pin{x}{l}{P} \).
A process is then \emph{well formed} if, for each of its structurally congruent processes of the form \( \Presd{x_1}{y_1}{\dots \Presd{x_n}{y_n}{(\Ppar{\Ppar{P}{Q}}{R})}} \), with \( n \geq 0 \), it holds that, if \( P \) is prefixed at \( x_1 \) and \( Q \) is prefixed at \( y_1 \), then \( \Ppar{P}{Q} \) is of the form \( \Ppar{\Pout{x_1}{a}{P'}}{\Pin{y_1}{l}{Q'}} \).

Note that well-formed processes do not necessarily reduce. For example, the process
\begin{equation*}
  \Presd{x_1}{y_1}{\Presd{x_2}{y_2}{(\Ppar{\Pout{x_1}{a}{\Pin{y_2}{l}{\Pend}}}{\Pout{y_2}{x_2}{\Pin{y_1}{l}{\Pend}}})}}
\end{equation*}
is well formed but also irreducible.

\begin{theorem}[Type safety]
  If \( \types{\Cempty}{P} \), then \( P \) is well formed.
\end{theorem}

\begin{corollary}
  If \( \types{\Cempty}{P} \) and \( \reduces{P}{Q} \) then \( Q \) is well formed.
\end{corollary}