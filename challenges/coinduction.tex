\subsection{Challenge: Coinduction and infinite processes}
% and reasoning about infinite processes}
\label{sec:challenge:coinduction}

% \marco{Why reasoning is only about infinite processes? Would it be
%   unreasonable to shorten the title to {\em Coinduction and infinite
%     processes}?}

This challenge is a about the mechanisation of proofs
% formalises a proof
that require coinduction.
% coinductive techniques.
%
% Coinduction is a proof technique for infinite structures,
This is usually connected to coinductive definitions where an infinite
structure is defined as greatest fixed points of a recursive
definition.
%
Coinduction is then a technique for defining and proving properties of
such infinite structures,
%
which, in the context of the concurrent benchmark, arise
% in this context
due to systems with behaviors that continue indefinitely.
%
Coinduction is the dual of induction: whereas induction is useful for
proving properties of least fixed points, coinduction is useful for
proving properties of greatest fixed points.
%
% \marco{Should we be more specific here and give a deeper explanation
%   of what coinduction is? If not, then why do we even say that it's
%   the dual of induction?}
%

For this challenge, we adopt a fragment of the untyped $\pi$-calculus
that includes process replication.
% The setting for this challenge is an untyped calculus of
% communicating systems with replication of processes, the syntax and
% semantics of which are presented below.
The objective of this challenge is to % prove % a context theorem for
draw a formal connection between strong barbed congruence and strong
barbed bisimilarity.  % I.e., The context lemma
The result establishes that two processes are strong barbed congruent
if the processes obtained by applying a finite number of substitutions to
them and composing them in parallel with an arbitrary process are
strongly barbed bisimilar.
The key issue of this challenge is the coinductive reasoning about the infinite behaviours of the replication operator.

\paragraph{Syntax.}
% We assume the existence of some type of \emph{base values}, values
% of which we will denote by \( a, b, \dots \), the existence of some
% type of \emph{variable names}, values of which we will denote by
% \( l, m, \dots \), and the existence of some type of \emph{names},
% values of which we will denote by \( x, y, \dots \).
The syntax of the calculus is identical to that of
Section~\ref{sec:challenge:linearity-beh-types} (challenge on
linearity), except from restriction, now unary, and the addition of
replication:
% for including replication and having unary restriction:
\begin{displaymath}
  \begin{array}{rcl}
    v,w & ::= & a \quad\mid\quad l \\
    P,Q & ::=& \Pend
               \quad \mid\quad \Pout{x}{v}{P}
               \quad \mid\quad \Pin{x}{l}{P}
               \quad \mid\quad \Ppar{P}{Q}
               \quad \mid\quad \Pres{x}{}{P}
               \quad \mid\quad !P
  \end{array}
\end{displaymath}
Note that, unlike the process calculus from
Section~\ref{sec:challenge:linearity-beh-types}, communications occur
over the same channel name. Moreover, since replication $!P$ allows
for infinite copies of the process $P$, processes can dynamically
create an infinite number of names during execution when combined with
restriction $\Pres{x}{}{P}$.
%
% \begin{align*}
%   v,w :=&&& a \\
%   |&&& l \\
%   P,Q :=&&& \Pend \\
%   |&&& \Pout{x}{v}{P} \\
%   |&&& \Pin{x}{l}{P} \\
%   |&&& \Ppar{P}{Q} \\
%   |&&& \Pres{x}{P} \\
%   |&&& \Preplicate{P}
% \end{align*}
% A \emph{value} \( v, w, \dots \) is either a base value \( a \) or a
% variable name \( l \).  The process \( \Pend \) is \emph{inaction}:
% a process which can do nothing.  The process \( \Pout{x}{a}{P} \) is
% an \emph{output}, which can send the value \( v \) via \( x \), then
% continue as \( P \).  The intention is that the value \( v \) must
% be a base value when it is actually sent, and this will be enforced
% in the semantics later on.  The process \( \Pin{x}{l}{P} \) is an
% \emph{input}, which can receive a base value via \( x \), then
% continue as \( P \) with the received value substituted for the
% variable name \( l \).  The input operator thus binds the variable
% name \( l \) in \( P \).  The process \( \Ppar{P}{Q} \) is the
% \emph{composition} of process \( P \) and process \( Q \).  The two
% components can proceed independently of each other, or they can
% interact via shared names.  The process \( \Pres{x}{P} \) is the
% \emph{restriction} of the name \( x \) to \( P \).  Components in
% \( P \) can use the name \( x \) to interact with each other, but
% not with processes outside of the restriction.  The restriction
% operator thus binds the name \( x \) in \( P \).  Note that the
% scope of a restriction may not change when processes interact, since
% it is only possible to send and receive values, and not names.  The
% process \( \Preplicate{P} \) is the \emph{replication} of the
% process \( P \).  It can be thought of as the infinite composition
% \( \Ppar{P}{\Ppar{P}{\cdots}} \).  Replication makes it possible to
% express infinite behaviours.

% We will use the notation \( \subst{P}{v}{l} \) to denote the process
% \( P \) with value \( v \) substituted for variable name \( l \).

% % We will use the notation \( \subst{P}{v}{w} \) to denote the process \( P \) with value \( v \) substituted for value \( w \).
% Two processes \( P \) and \( Q \) are \( \alpha \)-convertible,
% written \( \alphacon{P}{Q} \), if \( Q \) can be obtained from
% \( P \) by a finite number of substitutions of bound variable names.
% As a convention, we will identify \( \alpha \)-convertible
% processes.

% Also as a convention, we assume that the bound names and bound
% variable names occurring in any collection of processes are chosen
% to be different from the free names and free variable names
% occurring in those processes and from the names and variable names
% occurring in any substitutions applied to the processes.  This is
% justified because any overlapping names and variable names may be
% \( \alpha \)-converted such that the assumption is satisfied.

\paragraph{Semantics.} We choose to give an LTS semantics for this
challenge. As an alternative, it is also possible to adopt a reduction
semantics which features fewer rules but needs a structural
congruence. The semantics of the system describes the actions that the
system can perform by defining a labelled transition relation on
processes.  The transitions are labelled by \emph{actions}, the syntax
of which are as follows:
% \begin{align*}
%   \alpha := &&& \Aoutf{x}{a} \\
%   |&&& \Ain{x}{a} \\
%   |&&& \Atau
% \end{align*}
\begin{align*}
  \alpha\ :=\  \Aoutf{x}{a} \ \mid\ \Ain{x}{a} \ \mid\ \Atau
\end{align*}
The \emph{output action} \( \Aoutf{x}{y} \) is sending the base value
\( a \) via \( x \).  The \emph{input action} \( \Ain{x}{y} \) is
receiving the base value \( y \) via \( x \).  The \emph{internal
  action} \( \Atau \) is performing some unobservable action, e.g.\
internal communication.
%
We will use the notation \( \names{\alpha} \) to denote the set of
names that occur in the action \( \alpha \).

The transition relation is then defined by the following rules:
\begin{mathpar}
  \inferrule[Out]{ }{\transition{\Pout{x}{a}{P}}{\Aoutf{x}{a}}{P}}
  \and
  \inferrule[In]{ }{\transition{\Pin{x}{l}{P}}{\Ain{x}{a}}{\subst{P}{a}{l}}}
  \and
  \inferrule[Par-L]{\transition{P}{\alpha}{P'}}{\transition{\Ppar{P}{Q}}{\alpha}{\Ppar{P'}{Q}}}
  \and
  \inferrule[Par-R]{\transition{Q}{\alpha}{Q'}}{\transition{\Ppar{P}{Q}}{\alpha}{\Ppar{P}{Q'}}}
  \and
  \inferrule[Comm-L]{\transition{P}{\Aoutf{x}{a}}{P'} \\ \transition{Q}{\Ain{x}{a}}{Q'}}{\transition{\Ppar{P}{Q}}{\Atau}{\Ppar{P'}{Q'}}}
  \and
  \inferrule[Comm-R]{\transition{P}{\Ain{x}{a}}{P'} \\ \transition{Q}{\Aoutf{x}{a}}{Q'}}{\transition{\Ppar{P}{Q}}{\Atau}{\Ppar{P'}{Q'}}}
  \and
  \inferrule[Res]{\transition{P}{\alpha}{P'} \\ x \notin \names{\alpha}}{\transition{\Pres{x}{P}}{\alpha}{\Pres{x}{P'}}}
  \and
  \inferrule[Rep]{\transition{P}{\alpha}{P'}}{\transition{\Preplicate{P}}{\alpha}{\Ppar{P'}{\Preplicate{P}}}}
\end{mathpar}
Note that there is no rule for inferring transitions from \( \Pend \), and that there is no rule for inferring an action of an input or output process except those that match the input/output capability.
Note also that due to rule \TirName{In}, the process \( \Pin{x}{l}{P} \) can receive \emph{any} base value.
On the other hand, since the rule \TirName{Out} only applies to base values, there is no way to send a variable name.

% As a convention, we assume that bound names and bound variable names of any processes or actions are chosen to be different from the names and variable names that occur free in any other entities under consideration, such as processes, actions, substitutions, and sets of names or variable names.

\subsubsection{Bisimilarity}
Bisimilarity is a notion of equivalence for processes and
% .  Our notion of process equivalence relations
builds on a notion of \emph{observables}, i.e., what we can externally
observe from the semantics of a process. If we allow ourselves only to observe
internal transitions, i.e., observe that a process is internally
performing a step of computation, we will relate either too few
processes (in the strong case where we relate only processes with
exactly the same number of internal transitions) or every process (in
the weak case where we relate processes with any amount of internal
transitions).  We must therefore allow ourselves to observe more than
just internal transitions, and here choose to define the observables
of a process as the names it can use for sending and receiving.

To this end, we define the \emph{observability predicate}
\( \observable{P}{\mu} \) as follows:
\begin{align}
  \observable{P}{\obsin{x}}  &\quad \textrm{if \( P \) can perform an input action via \( x \).} \\
  \observable{P}{\obsout{x}} &\quad \textrm{if \( P \) can perform an output action via \( x \).}
\end{align}

\emph{Strong barbed bisimilarity}, written \( \sbbisim{}{} \), is then the largest symmetric relation such that, whenever \( \sbbisim{P}{Q} \):
\begin{gather}
  \observable{P}{\mu}~\textrm{implies}~\observable{Q}{\mu}\label{eq:bisim1} \\
  \transition{P}{\Atau}{P'}~\textrm{implies}~\transition{Q}{\Atau}{\sbbisim{}{} P'}\label{eq:bisim2}
\end{gather}
We say that a relation is a \emph{strong barbed bisimulation} if it satisfies the conditions given above, but is not necessarily the largest such relation, and that \( P \) and \( Q \) are \emph{strong barbed bisimilar} if \( \sbbisim{P}{Q} \).
Note that, since our systems have potentially infinite behaviors, and strong barbed bisimilarity is defined as the largest relation that satisfies the conditions, bisimulation cannot be defined inductively.

\begin{theorem}
  \( \sbbisim{}{} \) is an equivalence relation, that is, the relation is reflexive, symmetric, and transitive.
\end{theorem}
\begin{proof}
  % We need to prove that $\sbbisim{}{}$ is reflexive, symmetric, and
  % commutative.
  We prove the three properties separately: 
  \begin{itemize}
  \item Reflexivity is straightforward: for any $P$, we need to show
    that $P\sbbisim{}{} P$. Both conditions in
    equations~\ref{eq:bisim1} and \ref{eq:bisim2} follow trivially.
  \item Symmetry follows immediately since bisimilarity is defined as
    a {\em symmetric} relation.
  \item For transitivity, we need to prove that if $P\sbbisim{}{} Q$
    and $Q\sbbisim{}{} R$ then $P\sbbisim{}{} R$. In order to do so,
    we prove that the relation
    $\mathcal R=\{(P,R)\mid \exists Q\text{ such that }P\sbbisim{}{} Q
    \land Q\sbbisim{}{} R\}$ is a strong barbed bisimulation. Let us
    assume that $(P,R)\in\mathcal R$. Hence, there exists a $Q$ such
    that $P\sbbisim{}{} Q$ and $Q\sbbisim{}{} R$. Clearly, if
    $\observable{P}{\mu}$ then, by $P\sbbisim{}{} Q$,
    $\observable{Q}{\mu}$. And, by $Q\sbbisim{}{} R$,
    $\observable{R}{\mu}$. Moreover, if $\transition{P}{\Atau}{P'}$
    there exists $Q'$ such that $\transition{Q}{\Atau}{Q'}$ and
    $P'\sbbisim{}{}Q'$. And also, $\transition{R}{\Atau}{R'}$ with
    $Q'\sbbisim{}{}R'$. Finally, by definition of $\mathcal R$,
    $(P',R')\in\mathcal R$.
  \end{itemize}
  
\end{proof}

Unfortunately, strong barbed bisimilarity is not a good process
equivalence since it is not a congruence. This is because we wish to
be able to substitute a process with an equivalent one in any context
it may appear.
% equivalent processes to be since it does not consider the
% environment of processes.
For instance, the processes $\Pout{x}{a}{\Pout{y}{b}{\Pend}}$ and
$\Pout{x}{a}{\Pend}$ are strong barbed bisimilar, i.e.,
$\sbbisim{\Pout{x}{a}{\Pout{y}{b}{\Pend}}}{\Pout{x}{a}{\Pend}}$. This
is because \( \obsout{x} \) is the only observable in both processes
and they cannot perform a \( \Atau \)-action. However, if composed in
parallel with the process $\Pin{x}{l}{\Pend}$, the relation will no
longer hold. In fact,
$\nsbbisim{\Ppar{\Pout{x}{a}{\Pout{y}{b}{\Pend}}}{\Pin{x}{l}{\Pend}}}{\Pout{x}{a}{\Pend}\Ppar{}{\Pin{x}{l}{\Pend}}}$
%
because the left process can perform a \( \Atau \)-action such that
\( \obsout{y} \) becomes observable, whereas the right process cannot.

% For instance,
% \( \sbbisim{\Pout{x}{a}{\Pout{y}{b}{\Pend}}}{\Pout{x}{a}{\Pend}} \)
% since \( \obsout{x} \) is the only observable in both processes and
% they cannot perform a \( \Atau \)-action, but
% \(
% \nsbbisim{\Ppar{\Pout{x}{a}{\Pout{y}{b}{\Pend}}}{\Pin{x}{l}{\Pend}}}{\Pout{x}{a}{\Pend}}
% \) since the left process can perform a \( \Atau \)-action such that
% \( \obsout{y} \) becomes observable, whereas the right process cannot.

% \subsubsection{Contexts and congruences}
% Before we can fix the issue with strong barbed bisimilarity, we need few more definitions.

% A \emph{context} is obtained by taking a process and replacing a single occurrence of \( \Pend \) in it with the special \emph{hole} symbol \( \ctxhole \).
% As a convention, we do \emph{not} identify \( \alpha \)-convertible contexts.

% We can think of contexts as functions between processes.
% A context \( C \) can be \emph{applied} to a process \( P \), written \( \applyctx{C}{P} \), by replacing the hole in C by \( P \), thus obtaining another process.
% The replacement should be literal, so names and variable names that are free in \( P \) can become bound in \( \applyctx{C}{P} \).

% We say that an equivalence relation \( \mathcal{S} \) is a \emph{congruence} if \( (P,Q) \in \mathcal{S} \) implies that for any context \( C \), \( (\applyctx{C}{P}, \applyctx{C}{Q}) \in \mathcal{S} \).

\subsubsection{Strong barbed congruence}
In order to detect cases like the one above, we need to restrict strong barbed bisimilarity so that it becomes a congruence,
i.e., % we need to make strong barbed bisimilarity consider
we have to consider the environment in which processes may be placed.
% (i.e.\ the context) of processes.

We define \emph{strong barbed congruence}, written \( \sbcong{}{} \), by saying that two processes \( P \) and \( Q \) are \emph{strong barbed congruent}, written \( \sbcong{P}{Q} \), if \( \sbbisim{\applyctx{C}{P}}{\applyctx{C}{Q}} \) for every context \( C \).

\begin{lemma}
  \( \sbcong{}{} \) is the largest congruence included in
  \( \sbbisim{}{} \).
\end{lemma}
\begin{proof}
  By definition, \( \sbcong{}{} \) is a congruence and is included in
  \( \sbbisim{}{} \). Also, if it were strictly included in another
  relation then we would get a contradiction since it must be closed
  under all contexts.
\end{proof}

\subsubsection{Challenge}
The objective of this challenge is to prove a theorem that shows that
making strong barbed bisimilarity sensitive to substitution and
parallel composition is enough to show strong barbed
congruence.
To prove the theorem, we will use an \emph{up-to technique}.
A relation \( \mathcal{S} \) is called a \emph{strong barbed bisimulation up to \( \sbbisim{}{} \)} if, whenever \( (P,Q) \in \mathcal{S} \), the following conditions hold:
\begin{enumerate}
\item \( \observable{P}{\mu} \) if and only if \( \observable{Q}{\mu} \).
\item if \( \transition{P}{\Atau}{P'} \) then \( \transition{Q}{\Atau}{Q'} \) for some \( Q' \) with \( \uptosbb{P'}{\mathcal{S}}{Q'} \).
\item if \( \transition{Q}{\Atau}{Q'} \) then \( \transition{P}{\Atau}{P'} \) for some \( P' \) with \( \uptosbb{P'}{\mathcal{S}}{Q'} \).
\end{enumerate}
These relations are useful owing to the following lemma:
\begin{lemma}\label{lemma:up-to}
  If \( \mathcal{S} \) is a strong barbed bisimulation up to \( \sbbisim{}{} \), \( (P,Q) \in \mathcal{S} \) implies \( \sbbisim{P}{Q} \).
\end{lemma}
\begin{proof}
  We check that \( \uptosbb{}{\mathcal{S}}{} \) is a strong barbed bisimulation and is thus included in \( \sbbisim{}{} \).
\end{proof}

We are now ready to prove the theorem:
\begin{theorem}
  \( \sbcong{P}{Q} \) if, for any process \( R \) and
  substitution \( \sigma \),
  \(
  \sbbisim{\Ppar{\applysubst{\sigma}{P}}{R}}{\Ppar{\applysubst{\sigma}{Q}}{R}}
  \).
\end{theorem}
\begin{proof}
  Since \( \sbcong{}{} \) is the largest congruence included in \( \sbbisim{}{} \), it suffices to show that if \( \sbbisim{\Ppar{\applysubst{\sigma}{P}}{R}}{\Ppar{\applysubst{\sigma}{Q}}{R}} \) for any \( R \) and \( \sigma \), then \( \sbbisim{\Ppar{\applysubst{\sigma}{\applyctx{C}{P}}}{R}}{\Ppar{\applysubst{\sigma}{\applyctx{C}{Q}}}{R}} \) for any \( C \), \( R \) and \( \sigma \).
  We proceed by induction on \( C \).
  \begin{description}
  \item[\( C = \Pin{x}{z}{C'} \)] Let \( \mathcal{S} = \{ (\Ppar{\applysubst{\sigma}{\applyctx{C}{P}}}{R}, \Ppar{\applysubst{\sigma}{\applyctx{C}{Q}}}{R}) \mid \text{$R$ and $\sigma$ arbitrary} \}~\cup \sbbisim{}{} \).
    We can easily check that \( \mathcal{S} \) is a strong barbed bisimulation, noting that \( \sbbisim{}{} \) is preserved by restriction and is contained in \( \mathcal{S} \).
  \item[\( C = \Ppar{C'}{S} \)] Then by the induction hypothesis,
    \begin{equation*}
      \sbbisim{\sbbisim{\Ppar{\applysubst{\sigma}{\applyctx{C}{P}}}{R}}{\Ppar{\applysubst{\sigma}{\applyctx{C'}{P}}}{(\Ppar{\applysubst{\sigma}{S}}{R})}}}{\sbbisim{\Ppar{\applysubst{\sigma}{\applyctx{C'}{Q}}}{(\Ppar{\applysubst{\sigma}{S}}{R})}}{\Ppar{\applysubst{\sigma}{\applyctx{C}{Q}}}{R}}}
    \end{equation*}
    for any \( R \) and \( \sigma \).
  \item[\( C = \Pres{z}{C'} \)] Then by the induction hypothesis we have \( \sbbisim{\Ppar{\applysubst{\sigma}{\applyctx{C'}{P}}}{R}}{\Ppar{\applysubst{\sigma}{\applyctx{C'}{Q}}}{R}} \) for any \( R \) and \( \sigma \).
    Without loss of generality, we assume that \( z \notin \freenames{R} \cup \names{\sigma} \).
    Then, using that \( \sbbisim{}{} \) is preserved by restriction, we have
    \begin{equation*}
      \sbbisim{\sbbisim{\Ppar{\applysubst{\sigma}{\applyctx{C}{P}}}{R}}{\Pres{z}{(\Ppar{\applysubst{\sigma}{\applyctx{C'}{P}}}{R})}}}{\sbbisim{\Pres{z}{(\Ppar{\applysubst{\sigma}{\applyctx{C'}{Q}}}{R})}}{\Ppar{\applysubst{\sigma}{\applyctx{C}{Q}}}{R}}}
    \end{equation*}
  \item[\( C = \Preplicate{C'} \)] Let \( \mathcal{S} = \{ (\Ppar{\applysubst{\sigma}{\applyctx{C}{P}}}{R}, \Ppar{\applysubst{\sigma}{\applyctx{C}{Q}}}{R}) \mid \text{$R$ and $\sigma$ arbitrary} \} \).
    Using \cref{lemma:up-to}, it suffices to show that \( \mathcal{S} \) is a strong barbed bisimulation up to \( \sbbisim{}{} \).
    To this end, let
    \begin{align*}
      A &= \applysubst{\sigma}{\applyctx{C'}{P}}, & A' &= \applysubst{\sigma}{\applyctx{C}{P}} \\
      B &= \applysubst{\sigma}{\applyctx{C'}{Q}}, & B' &= \applysubst{\sigma}{\applyctx{C}{Q}} ,
    \end{align*}
    noting that \( A' = \Preplicate{A} \) and \( B' = \Preplicate{B} \).

    Suppose \( \transition{\Ppar{R}{A'}}{\Atau}{S} \) for some \( S \).
    Then we can show by a case analysis on the derivation of this transition that there exists a \( T \) such that \( \transition{\Ppar{R}{(\Ppar{A}{A})}}{\Atau}{T} \) and \( \sbbisim{S}{\Ppar{T}{A'}} \).
    Using the induction hypothesis twice, we note that \( \sbbisim{\Ppar{R}{B'}}{\Ppar{R}{\Ppar{(\Ppar{A}{A})}{B'}}} \).
    Since by rule \TirName{Par-L}, \( \transition{\Ppar{\Ppar{R}{(\Ppar{A}{A})}}{B'}}{\Atau}{\Ppar{T}{B'}} \), there must thus exist a \( U \) such that \( \transition{\Ppar{R}{B'}}{\Atau}{U} \), \( \sbbisim{U}{\Ppar{T}{B'}} \) and \( \uptosbb{S}{\mathcal{S}}{U} \) as required.
    The proof for \( \transition{\Ppar{R}{B'}}{\Atau}{S} \) is analogous.
  \end{description}
  The remaining cases are similar.
\end{proof}