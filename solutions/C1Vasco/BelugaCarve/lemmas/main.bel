%======================================================%
% Properties of typing judgment
%======================================================%

% If ฮ โข P, x :ฮฑ T โ ฮ, and x โ fv(P), then ฮฑ = ๐

rec oft_notin_fv : (ฮจ:ctx) (ฮ:[ฮจ,x:obj โข lctx K[]])
[ฮจ,x:obj โข oft ฮ P[..]] โ [ฮจ,x:obj โข upd ฮ n[] x Y T[] S[] ฮฑ[] ฮฒ[] ฮ']
โ [ โข mult_eq ฮฑ ๐] =
  / total g (oft_notin_fv g) /
  fn d, u โ
  let [_,x:obj โข U] = u in
  case d of
  | [_,x:obj โข oft/null E1] โ let [ โข hal/0] = exh_lookup [_ โข E1] u in [ โข mult/refl]
  | [_,x:obj โข oft/wait U1 D1] โ
    let [_,x:obj โข lookintm U2] = lookup_upd [_,x:obj โข U1] u (lookup_neq_var2nat [_,x:obj โข U1] u neq_top) in
    oft_notin_fv [_,x:obj โข D1] [_,x:obj โข U2]
  | [_,x:obj โข oft/close U1 D1] โ
    let [_,x:obj โข lookintm U2] = lookup_upd [_,x:obj โข U1] u (lookup_neq_var2nat [_,x:obj โข U1] u neq_top) in
    oft_notin_fv [_,x:obj โข D1] [_,x:obj โข U2]
  | [_,x:obj โข oft/inp U1 \y.D1] โ
    let [_,x:obj โข lookintm U2] = lookup_upd [_,x:obj โข U1] u (lookup_neq_var2nat [_,x:obj โข U1] u neq_top) in
    oft_notin_fv [_,y:obj,x:obj โข D1[..,x,y]] [_,y:obj,x:obj โข upd/n U2[..,x]]
  | [_,x:obj โข oft/out U1 U2 D1] โ
    let [_,x:obj โข lookintm U3] = lookup_upd [_,x:obj โข U1] u (lookup_neq_var2nat [_,x:obj โข U1] u neq_top) in
    let [_,x:obj โข lookintm U4] = lookup_upd [_,x:obj โข U2] [_,x:obj โข U3] (lookup_neq_var2nat [_,x:obj โข U2] [_,x:obj โข U3] neq_top) in
    oft_notin_fv [_,x:obj โข D1] [_,x:obj โข U4]
  | [_,x:obj โข oft/par D1 D2 M1] โ
    let [_,x:obj โข merge-look U1 U2 MLT[] _ _] = merge_lookup [_,x:obj โข U] [_,x:obj โข M1] in
    let [ โข mult/refl] = oft_notin_fv [_,x:obj โข D1] [_,x:obj โข U1] in
    let [ โข mult/refl] = oft_notin_fv [_,x:obj โข D2] [_,x:obj โข U2] in
    let [ โข โข/00] = [ โข MLT] in
    [ โข mult/refl]
  | [_,x:obj โข oft/res _ \y.\z.D1] โ
    oft_notin_fv [_,y:obj,z:obj,x:obj โข D1[..,x,y,z]] [_,y:obj,z:obj,x:obj โข upd/n (upd/n U[..,x])]
  ;

% If ฮ โข P then ฮ[x โ y] โข P

rec oft_exch : (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]]) [ฮจ โข oft ฮ P] โ [ฮจ โข exch ฮ n X m Y ฮ'] โ [ฮจ โข oft ฮ' P] =
  / total 1 /
  fn d, e โ
  let [_ โข exch/u NEQ[] EX1 EX2] = e in
  case d of
  | [_ โข oft/null E1] โ let [_ โข E2] = exch_exh [_ โข E1] e in [_ โข oft/null E2]
  | [_ โข oft/wait U1 D1] โ
    let [_ โข exch-e EX1' EX2' U2 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1] [_ โข EX2] [_ โข U1] in
    let [_ โข D2] = oft_exch [_ โข D1] [_ โข exch/u NEQ[] EX1' EX2'] in
    [_ โข oft/wait U2 D2]
  | [_ โข oft/close U1 D1] โ
    let [_ โข exch-e EX1' EX2' U2 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1] [_ โข EX2] [_ โข U1] in
    let [_ โข D2] = oft_exch [_ โข D1] [_ โข exch/u NEQ[] EX1' EX2'] in
    [_ โข oft/close U2 D2]
  | [_ โข oft/inp U1 \x.D1] โ
    let [_ โข exch-e EX1' EX2' U2 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1] [_ โข EX2] [_ โข U1] in
    let [_,x:obj โข D2] = oft_exch [_,x:obj โข D1] [_,x:obj โข exch/u NEQ[] (upd/n EX1'[..]) (upd/n EX2'[..])] in
    [_ โข oft/inp U2 \x.D2]
  | [_ โข oft/out U1 U2 D1] โ
    let [_ โข exch-e EX1' EX2' U3 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1] [_ โข EX2] [_ โข U1] in
    let [_ โข exch-e EX1'' EX2'' U4 _ _ _ _ _] = exch_upd [ โข NEQ] [_ โข EX1'] [_ โข EX2'] [_ โข U2] in
    let [_ โข D2] = oft_exch [_ โข D1] [_ โข exch/u NEQ[] EX1'' EX2''] in
    [_ โข oft/out U3 U4 D2]
  | [_ โข oft/par D1 D2 M1] โ
    let [_ โข exch-mg EX1a EX2a EX1b EX2b _ M2 _ _ _ _ _] = exch_merge [_ โข EX1] [_ โข EX2] [_ โข M1] in
    let [_ โข D1'] = oft_exch [_ โข D1] [_ โข exch/u NEQ[] EX1a EX2a] in
    let [_ โข D2'] = oft_exch [_ โข D2] [_ โข exch/u NEQ[] EX1b EX2b] in
    [_ โข oft/par D1' D2' M2]
  | [_ โข oft/res DU[] \x.\y.D1] โ
    let [_,x:obj,y:obj โข D2] = oft_exch [_,x:obj,y:obj โข D1] [_,x:obj,y:obj โข exch/u NEQ[] (upd/n (upd/n EX1[..])) (upd/n (upd/n EX2[..]))] in
    [_ โข oft/res DU[] \x.\y.D2]
  ;

rec oft_exch_top : (ฮจ:ctx) (ฮ:[ฮจ โข lctx N[]]) [ฮจ โข oft (cons (cons ฮ X A[] ฮฑ[]) Y B[] ฮฒ[]) P] โ [ฮจ โข oft (cons (cons ฮ Y B[] ฮฒ[]) X A[] ฮฑ[]) P] =
  / total /
  fn d โ oft_exch d (exch_top [_ โข _] [_ โข _] [ โข _] [ โข _] [_ โข _] [ โข _] [ โข _])
  ;

rec oft_exch_top2 : (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]])
[ฮจ โข oft (cons (cons (cons ฮ X A ฮฑ) Y B ฮฒ) Z C ฮณ) P] โ [ฮจ โข oft (cons (cons (cons ฮ Y B ฮฒ) Z C ฮณ) X A ฮฑ) P] =
  / total /
  fn d1 โ
  let [_ โข _]:[_ โข oft (cons (cons (cons ฮ X A[] ฮฑ[]) Y B[] ฮฒ[]) _ _ _) _] = d1 in
  let [_ โข exch/u NEQ[] EX1 EX2] = exch_top [_ โข ฮ] [_ โข X] [ โข A] [ โข ฮฑ] [_ โข Y] [ โข B] [ โข ฮฒ] in
  oft_exch_top (oft_exch d1 [_ โข exch/u NEQ[] (upd/n EX1) (upd/n EX2)])
  ;

% Strengthening lemma: If ฮ, x :โฐ T โข P, then x โ fv(P) and ฮ โข P

inductive StrTop: (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]]) {D:[ฮจ โข oft ฮ P]} ctype =
  | Str-Top : [ฮจ โข oft ฮ P] โ {D:[ฮจ,x:obj โข oft (cons ฮ[..] x A[] ๐) P[..]]} StrTop [ฮจ,x:obj โข D]
  ;

rec oft_str : {D:[ฮจ,x:obj โข oft (cons ฮ[..] x A[] ๐) P]} StrTop [ฮจ,x:obj โข D] =
  / total d (oft_str d) /
  mlam D โ case [_ โข D] of
  | [_,x:obj โข oft/null (exh/c E1 _)] โ
    let [_ โข E2] = prune_exh [_,x:obj โข E1] in
    Str-Top [_ โข oft/null E2] [_,x:obj โข _]
  | [_,x:obj โข oft/wait (upd/n U1) D1] โ
    let Prune-Upd [_ โข U2] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    let Str-Top [_ โข D2] [_,x:obj โข _] = oft_str [_,x:obj โข D1] in
    Str-Top [_ โข oft/wait U2 D2] [_,x:obj โข _]
  | [_,x:obj โข oft/close (upd/n U1) D1] โ
    let Prune-Upd [_ โข U2] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    let Str-Top [_ โข D2] [_,x:obj โข _] = oft_str [_,x:obj โข D1] in
    Str-Top [_ โข oft/close U2 D2] [_,x:obj โข _]
  | [_,x:obj โข oft/inp (upd/n U1) \y.D1] โ
    let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    let [_,x:obj,y:obj โข D1'] = oft_exch_top [_,y:obj,x:obj โข D1[..,x,y]] in
    let Str-Top [_,x:obj โข D2] [_,x:obj,y:obj โข _] = oft_str [_,x:obj,y:obj โข D1'] in
    Str-Top [_ โข oft/inp U1' \x.D2] [_,x:obj โข _]
  | [_,x:obj โข oft/out (upd/n U1) (upd/n U2) D1] โ
    let Prune-Upd [_ โข U1'] [_,x:obj โข _] = prune_upd [_,x:obj โข U1] in
    let Prune-Upd [_ โข U2'] [_,x:obj โข _] = prune_upd [_,x:obj โข U2] in
    let Str-Top [_ โข D2] [_,x:obj โข _] = oft_str [_,x:obj โข D1] in
    Str-Top [_ โข oft/out U1' U2' D2] [_,x:obj โข _]
  | [_,x:obj โข oft/par D1 D2 (mg/c M1 โข/00)] โ
    let Prune-Merge [_ โข M2] [_,x:obj โข _] = prune_merge [_,x:obj โข M1] in
    let Str-Top [_ โข D1'] [_,x:obj โข _] = oft_str [_,x:obj โข D1] in
    let Str-Top [_ โข D2'] [_,x:obj โข _] = oft_str [_,x:obj โข D2] in
    Str-Top [_ โข oft/par D1' D2' M2] [_,x:obj โข _]
  | [_,x:obj โข oft/res DU[] \y.\z.D1] โ
    let [_,x:obj,y:obj,z:obj โข D1'] = oft_exch_top2 [_,y:obj,z:obj,x:obj โข D1[..,x,y,z]] in
    let Str-Top [_,x:obj,y:obj โข D2] [_,x:obj,y:obj,z:obj โข _] = oft_str [_,x:obj,y:obj,z:obj โข D1'] in
    Str-Top [_ โข oft/res DU[] \x.\y.D2] [_,x:obj โข _]
  ;

% Weakening lemma: If ฮ โข P, then ฮ, x :โฐ T โข P

rec oft_weak : (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]])
[ฮจ โข oft ฮ P] โ {X:[ฮจ โข obj]} {T:[ โข tp]} โ [ฮจ โข oft (cons ฮ X T[] ๐) P] =
  / total 1 /
  fn d โ mlam X, T โ case d of
  | [_ โข oft/null E1] โ [_ โข oft/null (exh/c E1 hal/0)]
  | [_ โข oft/wait U1 D1] โ
    let [_ โข D1'] = oft_weak [_ โข D1] [_ โข X] [ โข T] in
    [_ โข oft/wait (upd/n U1) D1']
  | [_ โข oft/close U1 D1] โ
    let [_ โข D1'] = oft_weak [_ โข D1] [_ โข X] [ โข T] in
    [_ โข oft/close (upd/n U1) D1']
  | [_ โข oft/inp U1 \x.D1] โ
    let [_,x:obj โข D1'] = oft_exch_top (oft_weak [_,x:obj โข D1] [_,x:obj โข X[..]] [ โข T]) in
    [_ โข oft/inp (upd/n U1) \x.D1']
  | [_ โข oft/out U1 U2 D1] โ
    let [_ โข D1'] = oft_weak [_ โข D1] [_ โข X] [ โข T] in
    [_ โข oft/out (upd/n U1) (upd/n U2) D1']
  | [_ โข oft/par D1 D2 M1] โ
    let [_ โข D1'] = oft_weak [_ โข D1] [_ โข X] [ โข T] in
    let [_ โข D2'] = oft_weak [_ โข D2] [_ โข X] [ โข T] in
    [_ โข oft/par D1' D2' (mg/c M1 โข/00)]
  | [_ โข oft/res DU[] \x.\y.D1] โ
    let [_,x:obj,y:obj,z:obj โข D2] = oft_exch_top2 (oft_exch_top2 (oft_weak [_,x:obj,y:obj โข D1] [_,x:obj,y:obj โข X[..]] [ โข T])) in
    [_,x:obj โข oft/res DU[] \y.\z.D2]
  ;

% If ฮ โข P, then ฮ[x :โฐ T โฆ y :โฐ S] โข P for any y,S

rec oft_upd : (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]]) [ฮจ โข oft ฮ P] โ [ฮจ โข upd ฮ n[] X X' T[] T'[] ๐ ๐ ฮ']
โ [ฮจ โข oft ฮ' P] =
  / total 1 /
  fn d, u โ
  let [_ โข U] = u in
  case d of
  | [_ โข oft/null E1] โ
    let [_ โข E2] = exh_changetp [_ โข E1] [ โข hal/0] u in
    [_ โข oft/null E2]
  | [_ โข oft/wait U1 D1] โ
    let [_ โข upd-po U2 U3 _ _] = upd_pushout [_ โข U] [_ โข U1] (lookup_lab_neq_2 [_ โข U] [_ โข U1]) in
    let [_ โข D2] = oft_upd [_ โข D1] [_ โข U3] in
    [_ โข oft/wait U2 D2]
  | [_ โข oft/close U1 D1] โ
    let [_ โข upd-po U2 U3 _ _] = upd_pushout [_ โข U] [_ โข U1] (lookup_lab_neq_2 [_ โข U] [_ โข U1]) in
    let [_ โข D2] = oft_upd [_ โข D1] [_ โข U3] in
    [_ โข oft/close U2 D2]
  | [_ โข oft/inp U1 \x.D1] โ
    let [_ โข upd-po U2 U3 _ _] = upd_pushout [_ โข U] [_ โข U1] (lookup_lab_neq_2 [_ โข U] [_ โข U1]) in
    let [_,x:obj โข D2] = oft_upd [_,x:obj โข D1] [_,x:obj โข upd/n U3[..]] in
    [_ โข oft/inp U2 \x.D2]
  | [_ โข oft/out U1 U2 D1] โ
    let [_ โข upd-po U3 U4 _ _] = upd_pushout [_ โข U] [_ โข U1] (lookup_lab_neq_2 [_ โข U] [_ โข U1]) in
    let [_ โข upd-po U5 U6 _ _] = upd_pushout [_ โข U4] [_ โข U2] (lookup_lab_neq_2 [_ โข U4] [_ โข U2]) in
    let [_ โข D2] = oft_upd [_ โข D1] [_ โข U6] in
    [_ โข oft/out U3 U5 D2]
  | [_ โข oft/par D1 D2 M1] โ
    let [_ โข merge-upd U1 U2 โข/00 M2 _ _ _] = merge_upd_cor [_ โข U] [_ โข M1] [ โข โข/00] in
    let [_ โข D1'] = oft_upd [_ โข D1] [_ โข U1] in
    let [_ โข D2'] = oft_upd [_ โข D2] [_ โข U2] in
    [_ โข oft/par D1' D2' M2]
  | [_ โข oft/res DU[] \x.\y.D1] โ
    let [_,x:obj,y:obj โข D1'] = oft_upd [_,x:obj,y:obj โข D1] [_,x:obj,y:obj โข upd/n (upd/n U[..])] in
    [_ โข oft/res DU[] \x.\y.D1']
  ;

% Substitution / renaming lemma:
% If ฮ, x :ยน T โข P, then ฮ[y :โฐ T โฆโ y :ยน T] โข P[y/x]

rec oft_rename : (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]]) [ฮจ,x:obj โข oft (cons ฮ[..] x T[] ๐) P] โ [ฮจ โข upd ฮ n[] X X T[] T[] ๐ ๐ ฮ']
โ [ฮจ โข oft ฮ' P[..,X]] =
  / total d (oft_rename d) /
  fn d, u โ
  let [_ โข U] = u in
  let [_ โข U'] = upd_symm u in
  case d of
  | [_,x:obj โข oft/null (exh/c _ UN[])] โ impossible [ โข UN]
  | [_,x:obj โข oft/wait U1 D1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let Str-Top [_ โข D1'] [_,x:obj โข _] = oft_str [_,x:obj โข D1] in
      [_ โข oft/wait U' D1']
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข U1''] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_ โข upd-po U2 U3 _ _] = upd_pushout [_ โข U] [_ โข U1''] (lookup_lab_neq_2 [_ โข U] [_ โข U1'']) in
      let [_ โข D1'] = oft_rename [_,x:obj โข D1] [_ โข U3] in
      [_ โข oft/wait U2 D1']
    )
  | [_,x:obj โข oft/close U1 D1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let Str-Top [_ โข D1'] [_,x:obj โข _] = oft_str [_,x:obj โข D1] in
      [_ โข oft/close U' D1']
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข U1''] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_ โข upd-po U2 U3 _ _] = upd_pushout [_ โข U] [_ โข U1''] (lookup_lab_neq_2 [_ โข U] [_ โข U1'']) in
      let [_ โข D1'] = oft_rename [_,x:obj โข D1] [_ โข U3] in
      [_ โข oft/close U2 D1']
    )
  | [_,x:obj โข oft/inp U1 \y.D1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_ โข _]:[_ โข upd _ _ Z Z (recv T[] S[]) (recv T[] S[]) ๐ ๐ ฮ'] = u in
      let [_ โข get-upd U2] = lookup_getupd (upd_symm u) [_ โข Z] [ โข S] [ โข ๐] in
      let [_ โข get-upd U3] = lookup_getupd (upd_symm u) [_ โข Z] [ โข S] [ โข ๐] in
      let [_ โข U4] = upd_trans u [_ โข U2] in
      let [_ โข U5] = upd_trans (upd_symm [_ โข U2]) [_ โข U3] in
      let [_,x:obj,y:obj โข D1'] = oft_exch_top (oft_upd [_,x:obj,y:obj โข D1] [_,x:obj,y:obj โข upd/n (upd/n U4[..])]) in
      let [_,x:obj โข D1''] = oft_rename [_,x:obj,y:obj โข D1'[..,y,x]] [_,x:obj โข upd/n U5[..]] in
      [_ โข oft/inp U3 \x.D1'']
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข U1''] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_ โข upd-po U3 U4 _ _] = upd_pushout [_ โข U] [_ โข U1''] (lookup_lab_neq_2 [_ โข U] [_ โข U1'']) in
      let [_,x:obj โข D1'] = oft_rename (oft_exch_top [_,x:obj,y:obj โข D1[..,y,x]]) [_,x:obj โข upd/n U4[..]] in
      [_ โข oft/inp U3 \x.D1']
    )
  | [_,x:obj โข oft/out U1 U2 D1] โ
    (case [_,x:obj โข U1] of
    | [_,x:obj โข upd/t _] โ
      let [_,x:obj โข upd/n U2'] = [_,x:obj โข U2] in
      let Prune-Upd [_ โข U2''] [_,x:obj โข _] = prune_upd [_,x:obj โข U2'] in
      let Str-Top [_ โข D1'] [_,x:obj โข _] = oft_str [_,x:obj โข D1] in
      [_ โข oft/out U' U2'' D1']
    | [_,x:obj โข upd/n U1'] โ
      let Prune-Upd [_ โข U1''] [_,x:obj โข _] = prune_upd [_,x:obj โข U1'] in
      let [_ โข upd-po U3 U4 _ _] = upd_pushout [_ โข U] [_ โข U1''] (lookup_lab_neq_2 [_ โข U] [_ โข U1'']) in
      (case [_,x:obj โข U2] of
      | [_,x:obj โข upd/t _] โ
        let [_ โข _]:[_ โข upd _ _ X X (send T[] S[]) (send T[] S[]) ๐ ๐ ฮ''] = [_ โข U4] in
        let [_ โข get-upd U5] = lookup_getupd [_ โข U4] [_ โข X] [ โข S] [ โข ๐] in
        let [_ โข get-upd U6] = lookup_getupd [_ โข U4] [_ โข X] [ โข S] [ โข ๐] in
        let [_ โข U7] = upd_trans (upd_symm [_ โข U4]) [_ โข U6] in
        let [_,x:obj โข D1'] = oft_upd [_,x:obj โข D1] [_,x:obj โข upd/n U5[..]] in
        let [_ โข D1''] = oft_rename [_,x:obj โข D1'] (upd_trans (upd_symm [_ โข U5]) [_ โข U6]) in
        [_ โข oft/out U3 U7 D1'']
      | [_,x:obj โข upd/n U2'] โ
        let Prune-Upd [_ โข U2''] [_,x:obj โข _] = prune_upd [_,x:obj โข U2'] in
        let [_ โข upd-po U5 U6 _ _] = upd_pushout [_ โข U4] [_ โข U2''] (lookup_lab_neq_2 [_ โข U4] [_ โข U2'']) in
        let [_ โข D1'] = oft_rename [_,x:obj โข D1] [_ โข U6] in
        [_ โข oft/out U3 U5 D1']
      )
    )
  | [_,x:obj โข oft/par D1 D2 (mg/c M1 T[])] โ
    let Prune-Merge [_ โข M2] [_,x:obj โข _] = prune_merge [_,x:obj โข M1] in
    let [_ โข merge-upd U1 U2 โข/00 M2 _ _ _] = merge_upd_cor [_ โข U] [_ โข M2] [ โข T] in
    (case [ โข T] of
    | [ โข โข/10] โ
      let [_ โข cx/refl] = upd_refl2 [_ โข U2] in
      let [_ โข D1'] = oft_rename [_,x:obj โข D1] [_ โข U1] in
      let Str-Top [_ โข D2'] [_,x:obj โข _] = oft_str [_,x:obj โข D2] in
      [_ โข oft/par D1' D2' M2]
    | [ โข โข/01] โ
      let [_ โข cx/refl] = upd_refl2 [_ โข U1] in
      let Str-Top [_ โข D1'] [_,x:obj โข _] = oft_str [_,x:obj โข D1] in
      let [_ โข D2'] = oft_rename [_,x:obj โข D2] [_ โข U2] in
      [_ โข oft/par D1' D2' M2]
    )
  | [_,x:obj โข oft/res DU[] \y.\z.D1] โ
    let [_,x:obj,y:obj โข D1'] = oft_rename (oft_exch_top2 [_,y:obj,z:obj,x:obj โข D1[..,x,y,z]]) [_,x:obj,y:obj โข upd/n (upd/n U[..])] in
    [_ โข oft/res DU[] \x.\y.D1']
  ;

% Preservation for โก

rec oft_cong : (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]]) [ฮจ โข P โก Q] โ [ฮจ โข oft ฮ P] โ [ฮจ โข oft ฮ Q] =
  / total 1 /
  fn c, d โ case c of
  % axioms
  | [_ โข โกpar/comm] โ
    let [_ โข oft/par D1 D2 M] = d in
    let [_ โข M'] = merge_comm [_ โข M] in
    [_ โข oft/par D2 D1 M']
  | [_ โข โกpar/assoc] โ
    let [_ โข oft/par (oft/par D1 D2 M1) D3 M2] = d in
    let [_ โข mg-assoc M3 M4 _ _] = merge_assoc [_ โข M2] [_ โข M1] in
    [_ โข oft/par D1 (oft/par D2 D3 M3) M4]
  | [_ โข โกpar/null _] โ
    let [_ โข oft/par D1 (oft/null E) M] = d in
    let [_ โข cx/refl] = merge_id (merge_comm [_ โข M]) [_ โข E] in
    [_ โข D1]
  | [_ โข โกres/par] โ
    let [_ โข oft/par (oft/res DU[] \x.\y.D1) D2 M] = d in
    let [ โข _]:[ โข dual T T'] = [ โข DU] in
    let [_,x:obj โข D3'] = oft_weak [_,x:obj โข D2[..]] [_,x:obj โข x] [ โข T] in
    let [_,x:obj,y:obj โข D3] = oft_weak [_,x:obj,y:obj โข D3'[..,x]] [_,x:obj,y:obj โข y] [ โข T'] in
    [_ โข oft/res DU[] \x.\y.oft/par D1 D3 (mg/c (mg/c M[..] โข/10) โข/10)]
  | [_ โข โกres] โ
    let [_ โข oft/res DU1[] \w.\x.oft/res DU2[] \y.\z.D1] = d in
    let [_,w:obj,x:obj,y:obj,z:obj โข _]:[_,w:obj,x:obj,y:obj,z:obj โข oft (cons (cons (cons (cons ฮ[..] _ T[] _) _ T'[] _) _ U[] _) _ U'[] _) _] = [_,w:obj,x:obj,y:obj,z:obj โข D1] in
    let [_,x:obj,y:obj โข exch/u NEQ[] EX1 EX2] = exch_top [_,x:obj,y:obj โข ฮ[..]] [_,x:obj,y:obj โข x] [ โข T] [ โข ๐] [_,x:obj,y:obj โข y] [ โข U] [ โข ๐] in
    let [_,w:obj,x:obj,y:obj,z:obj โข D2'[..,y,z,w,x]] = oft_exch_top (oft_exch_top2 (oft_exch (oft_exch_top2 [_,w:obj,x:obj,y:obj,z:obj โข D1])
      [_,w:obj,x:obj,y:obj,z:obj โข exch/u NEQ[] (upd/n (upd/n EX1[..,w,y])) (upd/n (upd/n EX2[..,w,y]))])) in
    [_ โข oft/res DU2[] \w.\x.oft/res DU1[] \y.\z.D2']
  % congruence rules
  | [_ โข โกc/null] โ d
  | [_ โข โกc/wait C1] โ
    let [_ โข oft/wait U1 D1] = d in
    let [_ โข D1'] = oft_cong [_ โข C1] [_ โข D1] in
    [_ โข oft/wait U1 D1']
  | [_ โข โกc/close C1] โ
    let [_ โข oft/close U1 D1] = d in
    let [_ โข D1'] = oft_cong [_ โข C1] [_ โข D1] in
    [_ โข oft/close U1 D1']
  | [_ โข โกc/inp \x.C1] โ
    let [_ โข oft/inp U1 \x.D1] = d in
    let [_,x:obj โข D1'] = oft_cong [_,x:obj โข C1] [_,x:obj โข D1] in
    [_ โข oft/inp U1 \x.D1']
  | [_ โข โกc/out C1] โ
    let [_ โข oft/out U1 U2 D1] = d in
    let [_ โข D1'] = oft_cong [_ โข C1] [_ โข D1] in
    [_ โข oft/out U1 U2 D1']
  | [_ โข โกc/par C1] โ % C2
    let [_ โข oft/par D1 D2 M] = d in
    let [_ โข D1'] = oft_cong [_ โข C1] [_ โข D1] in
    %let [_ โข D2'] = oft_cong [_ โข C2] [_ โข D2] in
    [_ โข oft/par D1' D2 M]
  | [_ โข โกc/res \x.\y.C1] โ
    let [_ โข oft/res DU[] \x.\y.D1] = d in
    let [_,x:obj,y:obj โข D1'] = oft_cong [_,x:obj,y:obj โข C1] [_,x:obj,y:obj โข D1] in
    [_ โข oft/res DU[] \x.\y.D1']
  % symmetry, transitivity
  | [_ โข โกsym C1] โ oft_cong_symm [_ โข C1] d
  | [_ โข โกtrans C1 C2] โ oft_cong [_ โข C2] (oft_cong [_ โข C1] d)

and rec oft_cong_symm : (ฮจ:ctx) (ฮ:[ฮจ โข lctx K[]]) [ฮจ โข P โก Q] โ [ฮจ โข oft ฮ Q] โ [ฮจ โข oft ฮ P] =
  / total 1 /
  fn c, d โ case c of
  | [_ โข โกpar/comm] โ
    let [_ โข oft/par D1 D2 M] = d in
    let [_ โข M'] = merge_comm [_ โข M] in
    [_ โข oft/par D2 D1 M']
  | [_ โข โกpar/assoc] โ
    let [_ โข oft/par D1 (oft/par D2 D3 M1) M2] = d in
    let [_ โข M2'] = merge_comm [_ โข M2] in
    let [_ โข mg-assoc2 M3' M4 _ _] = merge_assoc_2 [_ โข M2'] [_ โข M1] in
    let [_ โข M3] = merge_comm [_ โข M3'] in
    [_ โข oft/par (oft/par D1 D2 M3) D3 M4]
  | [_ โข โกpar/null _] โ
    let [_ โข D1]:[_ โข oft ฮ _] = d in
    let [_ โข merge-getid M E1] = merge_getid [_ โข ฮ] in
    [_ โข oft/par D1 (oft/null E1) M]
  | [_ โข โกres/par] โ
    let [_ โข oft/res DU[] \x.\y.oft/par D1 D2 (mg/c (mg/c M1 T1[]) T2[])] = d in
    let Prune-Merge [_,x:obj โข M1'] [_,x:obj,y:obj โข _] = prune_merge [_,x:obj,y:obj โข M1] in
    let Prune-Merge [_ โข M2] [_,x:obj โข _] = prune_merge [_,x:obj โข M1'] in
    let [ โข mult/refl] = oft_notin_fv [_,x:obj,y:obj โข D2] (refl_top [_ โข _] [_ โข _] [ โข _] [ โข _]) in
    let Str-Top [_,x:obj โข D2'] [_,x:obj,y:obj โข _] = oft_str [_,x:obj,y:obj โข D2] in
    let [ โข mult/refl] = oft_notin_fv [_,x:obj โข D2'] (refl_top [_ โข _] [_ โข _] [ โข _] [ โข _]) in
    let Str-Top [_ โข D2''] [_,x:obj โข _] = oft_str [_,x:obj โข D2'] in
    let ([ โข โข/10],[ โข โข/10]) = ([ โข T1],[ โข T2]) in
    [_ โข oft/par (oft/res DU[] \x.\y.D1) D2'' M2]
  | [_ โข โกres] โ
    let [_ โข oft/res DU1[] \w.\x.oft/res DU2[] \y.\z.D1] = d in
    let [_,w:obj,x:obj,y:obj,z:obj โข _]:[_,w:obj,x:obj,y:obj,z:obj โข oft (cons (cons (cons (cons ฮ[..] _ T[] _) _ T'[] _) _ U[] _) _ U'[] _) _] = [_,w:obj,x:obj,y:obj,z:obj โข D1] in
    let [_,x:obj,y:obj โข exch/u NEQ[] EX1 EX2] = exch_top [_,x:obj,y:obj โข ฮ[..]] [_,x:obj,y:obj โข x] [ โข T] [ โข ๐] [_,x:obj,y:obj โข y] [ โข U] [ โข ๐] in
    let [_,w:obj,x:obj,y:obj,z:obj โข D2'[..,y,z,w,x]] = oft_exch_top (oft_exch_top2 (oft_exch (oft_exch_top2 [_,w:obj,x:obj,y:obj,z:obj โข D1])
      [_,w:obj,x:obj,y:obj,z:obj โข exch/u NEQ[] (upd/n (upd/n EX1[..,w,y])) (upd/n (upd/n EX2[..,w,y]))])) in
    [_ โข oft/res DU2[] \w.\x.oft/res DU1[] \y.\z.D2']
  % congruence rules
  | [_ โข โกc/null] โ d
  | [_ โข โกc/wait C1] โ
    let [_ โข oft/wait U1 D1] = d in
    let [_ โข D1'] = oft_cong_symm [_ โข C1] [_ โข D1] in
    [_ โข oft/wait U1 D1']
  | [_ โข โกc/close C1] โ
    let [_ โข oft/close U1 D1] = d in
    let [_ โข D1'] = oft_cong_symm [_ โข C1] [_ โข D1] in
    [_ โข oft/close U1 D1']
  | [_ โข โกc/inp \x.C1] โ
    let [_ โข oft/inp U1 \x.D1] = d in
    let [_,x:obj โข D1'] = oft_cong_symm [_,x:obj โข C1] [_,x:obj โข D1] in
    [_ โข oft/inp U1 \x.D1']
  | [_ โข โกc/out C1] โ
    let [_ โข oft/out U1 U2 D1] = d in
    let [_ โข D1'] = oft_cong_symm [_ โข C1] [_ โข D1] in
    [_ โข oft/out U1 U2 D1']
  | [_ โข โกc/par C1] โ % C2
    let [_ โข oft/par D1 D2 M] = d in
    let [_ โข D1'] = oft_cong_symm [_ โข C1] [_ โข D1] in
    %let [_ โข D2'] = oft_cong_symm [_ โข C2] [_ โข D2] in
    [_ โข oft/par D1' D2 M]
  | [_ โข โกc/res \x.\y.C1] โ
    let [_ โข oft/res DU[] \x.\y.D1] = d in
    let [_,x:obj,y:obj โข D1'] = oft_cong_symm [_,x:obj,y:obj โข C1] [_,x:obj,y:obj โข D1] in
    [_ โข oft/res DU[] \x.\y.D1']
  % symmetry, transitivity
  | [_ โข โกsym C1] โ oft_cong [_ โข C1] d
  | [_ โข โกtrans C1 C2] โ oft_cong_symm [_ โข C1] (oft_cong_symm [_ โข C2] d)
  ;