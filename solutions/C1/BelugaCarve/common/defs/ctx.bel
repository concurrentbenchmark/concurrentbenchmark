%======================================================%
% Explicit contexts
%======================================================%

%------------------------------------------------------%
% Length-indexed typing contexts
%------------------------------------------------------%

LF lctx : nat â†’ type =
| nil : lctx zero
| cons : lctx N â†’ obj â†’ tp â†’ mult â†’ lctx (suc N);

% Typing context equality

LF cx_eq : lctx N â†’ lctx N â†’ type =
| cx/refl : cx_eq Î” Î”;

%------------------------------------------------------%
% Main operations on typing contexts
%------------------------------------------------------%

% Splitting / merging typing contexts: Î”â‚ â‹ˆ Î”â‚‚ = Î”

LF merge : lctx N â†’ lctx N â†’ lctx N â†’ type =
| mg/n : merge nil nil nil
| mg/c : merge Î”â‚ Î”â‚‚ Î” â†’ â€¢ Î±â‚ Î±â‚‚ Î± â†’ merge (cons Î”â‚ X A Î±â‚) (cons Î”â‚‚ X A Î±â‚‚) (cons Î” X A Î±);

% Î”[x :Î± A â†¦â‚™ y :Î² B] = Î”'
% i.e., x appears in Î” at position n with type A and multiplicity Î±, and 
% Î”' is the result of changing that entry to y :Î² B

LF upd : lctx N â†’ nat â†’ obj â†’ obj â†’ tp â†’ tp â†’ mult â†’ mult â†’ lctx N â†’ type =
| upd/t : {Î”:lctx N} upd (cons Î” X A Î±) (suc N) X X' A A' Î± Î±' (cons Î” X' A' Î±')
| upd/n : upd Î” n X X' A A' Î± Î±' Î”' â†’ upd (cons Î” Y B Î²) n X X' A A' Î± Î±' (cons Î”' Y B Î²);

% Only unrestricted assumptions appear in Î”,
% parametric to the predicate "hal Î±"; in the case of linear type systems,
% "hal Î±" holds when Î± = ğŸ˜ (unavailable).

LF exh : lctx _ â†’ type =
| exh/n : exh nil
| exh/c : exh Î” â†’ hal Î± â†’ exh (cons Î” _ _ Î±);

% Î” â‰ˆ Î”', Î” = Î”' up to varying multiplicities
% (corresponds to 0Î” = 0Î”' for linear systems)

LF same_elts: lctx N â†’ lctx N â†’ type =
| se/n : same_elts nil nil
| se/c : same_elts Î” Î”' â†’ same_elts (cons Î” X A _) (cons Î”' X A _);

%------------------------------------------------------%
% Shorthand for other properties
%------------------------------------------------------%

% Î”[(n, x) â†” (m, y)] = Î”', i.e., permute two distinct elements of a typing context

LF exch : lctx N â†’ nat â†’ obj â†’ nat â†’ obj â†’ lctx N â†’ type =
| exch/u : neq n m â†’ upd Î” n X Y A B Î± Î² Î”'' â†’ upd Î”'' m Y X B A Î² Î± Î”' â†’ exch Î” n X m Y Î”';

% Look up name, type, and multiplicity

LF lookup : obj â†’ tp â†’ mult â†’ lctx _ â†’ type = 
| look : upd Î” _ X X A A Î± Î± Î” â†’ lookup X A Î± Î”;

% Look up name

LF lookup_n : obj â†’ lctx _ â†’ type = 
| lookn : upd Î” _ X _ _ _ _ _ _ â†’ lookup_n X Î”;

% Look up index and name

LF lookup_in : nat â†’ obj â†’ lctx _ â†’ type = 
| lookin : upd Î” n X X A A Î± Î± Î” â†’ lookup_in n X Î”;

% Look up index, name, and type

LF lookup_int : nat â†’ obj â†’ tp â†’ lctx _ â†’ type = 
| lookint : upd Î” n X X A A Î± Î± Î” â†’ lookup_int n X A Î”;

% Look up index, name, type, and multiplicity

LF lookup_intm : nat â†’ obj â†’ tp â†’ mult â†’ lctx _ â†’ type =
| lookintm : upd Î” n X X A A Î± Î± Î” â†’ lookup_intm n X A Î± Î”;

%------------------------------------------------------%
% Well-formedness conditions
%------------------------------------------------------%

% Context contains no duplicate names and only elements of the LF context

inductive Wf : (Î¨:ctx) {Î”:[Î¨ âŠ¢ lctx k]} ctype =
| Wf/n : Wf [_ âŠ¢ nil]
| Wf/c : Wf [_ âŠ¢ Î”] â†’ ([_ âŠ¢ lookup_n #p Î”] â†’ [ âŠ¢ false]) â†’ Wf [_ âŠ¢ cons Î” #p _ _];

% Context contains only variables from the LF context

inductive VarCtx : (Î¨:ctx) {Î”:[Î¨ âŠ¢ lctx k]} ctype =
| VCtx/n : VarCtx [_ âŠ¢ nil]
| VCtx/c : VarCtx [_ âŠ¢ Î”] â†’ VarCtx [_ âŠ¢ cons Î” #p _ _];