\documentclass[runningheads]{llncs}
\synctex=1
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{mathpartir}
\usepackage{cite}
\usepackage{bm}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{hyperref}
\usepackage{microtype}
\usepackage[inline]{enumitem}
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage[status=draft]{fixme}
\fxsetup{theme=color}
% \setlength{\textwidth}{12.4cm}
\setlength{\textheight}{19.9cm}

\input{../macros.tex}

\begin{document}

\title{The Concurrent Calculi Formalisation Benchmark}

\author{
     Marco Carbone \inst{1}\orcidID{0000-0001-9479-2632}
\and David Castro-Perez \inst{2}\orcidID{0000-0002-6939-4189}
\and Francisco Ferreira \inst{3}\orcidID{0000-0001-8494-7696}
\and Lorenzo Gheri \inst{4}\orcidID{0000-0002-3191-7722}
\and Frederik Krogsdal Jacobsen \inst{5}\orcidID{0000-0003-3651-8314}
\and Alberto Momigliano \inst{6}\orcidID{0000-0003-0942-4777}
\and Luca Padovani \inst{7}\orcidID{0000-0001-9097-1297}
\and Alceste Scalas \inst{5}\orcidID{0000-0002-1153-6164}
\and Dawit Tirore \inst{1}\orcidID{0000-0002-1997-5161}
\and Martin Vassor \inst{8}\orcidID{0000-0002-2057-0495}
\and Nobuko Yoshida \inst{8}\orcidID{0000-0002-3925-8557}
\and Daniel Zackon \inst{9}\orcidID{0009-0008-6153-2955}
}

\institute{
     IT University of Copenhagen, Copenhagen, Denmark \email{maca@itu.dk}, \email{dati@itu.dk}
\and University of Kent, Canterbury, United Kingdom \email{D.Castro-Perez@kent.ac.uk}
\and Royal Holloway, University of London, Egham, United Kingdom \email{Francisco.FerreiraRuiz@rhul.ac.uk}
\and University of Liverpool, Liverpool, United Kingdom \email{Lorenzo.Gheri@liverpool.ac.uk}
\and Technical University of Denmark, Kgs. Lyngby, Denmark \email{fkjac@dtu.dk}, \email{alcsc@dtu.dk}
\and Università degli Studi di Milano, Milan, Italy \email{momigliano@di.unimi.it}
\and Università di Camerino, Camerino, Italy \email{luca.padovani@unicam.it}
\and University of Oxford, Oxford, United Kingdom \email{martin.vassor@cs.ox.ac.uk}, \email{nobuko.yoshida@cs.ox.ac.uk}
\and McGill University, Montreal, Canada \email{daniel.zackon@mcgill.ca}
}

\authorrunning{M. Carbone et al.}

\maketitle

\begin{abstract}
  %% AM: implemented DZ
% when mechanising  message-passing concurrency using process calculi.
  
  POPLMark and POPLMark Re\-loaded sparked a flurry of
  work on machine-checked proofs, and fostered the adoption of proof
  mechanisation in programming language research. Both challenges were purposely limited in scope, and their benchmark problems do not address concurrency-related issues.
  %
  For this reason, we propose a new collection of benchmark problems
  focused on the difficulties that typically arise when mechanising
  formal models of concurrent and distributed programming languages,
  such as process calculi.  Our benchmark problems address three key
  topics: linearity, scope extrusion, and coinductive reasoning.  The
  goal of this new challenge is to clarify, compare, and advance the
  state of the art, fostering the adoption of proof mechanisation in
  future research on message-passing concurrency.

\keywords{Mechanisation \and Process calculi \and Benchmark \and Coinduction \and Scope extrusion \and Linearity}
\end{abstract}

\section{Introduction}
By establishing a common ground for systematically evaluating mechanisation techniques, 
the POPLMark challenge~\cite{POPLMark} accelerated progress in 
the development of proof assistants, libraries, and best practices. In doing so, it 
spearheaded a shift in the programming language research community towards 
publications that include mechanised proofs. 
Its follow-up challenge, POPLMark Reloaded~\cite{POPLMarkReloaded}, 
% facilitated the development of best practices and tool support
aimed to run the same program for proofs 
using logical relations. These challenges were deliberately limited in scope, 
while their authors called for future investigations into such areas as 
coinduction and linear environments. In this spirit, we propose a 
new collection of benchmark problems specifically designed to address typical 
issues that arise when mechanising message-passing concurrency using process 
calculi.

\alb{Is there a sharp difference among those papers?}
Several papers in this realm already include mechanised proofs
(\eg~\cite{Castro-Perez2021,Castro2020,lmcs:9985,
  DBLP:journals/jar/CruzFilipeMP23, Tirore:2023}), or discuss proof mechanisation techniques
(\eg~\cite{Bengtson2016, Gay2001,
  Thiemann2019, DBLP:conf/forte/ZalakainD21}).  Our
experience, however, is that choosing the appropriate proof mechanisation techniques and 
tools remains a significant challenge with a limited understanding of their 
respective trade-offs.  This often leads researchers toward a trial-and-error approach, 
resulting in sub-optimal and ad-hoc solutions. In turn, this increases the overall effort 
required for proof mechanisation, and hampers the reuse of techniques and results.
%
It is therefore our view that the research community in message-passing
concurrency (and process calculi, more specifically) will benefit from a standardised set
of challenge problems.

To this end, our benchmark problems (discussed in detail in \cref{app:challenges}) are designed to focus on three key aspects which typically cause difficulties 
when mechanising concurrency theory: \emph{linearity}, \emph{scope extrusion}, 
and \emph{coinductive reasoning} for infinite behaviours. These are certainly not the only factors that may cause issues, but they
are fundamental to concurrency theory, and emerge in most mechanisations.
The mechanisation of novel research results often requires addressing more than
just one of these aspects at once; we see the combination of techniques
as a next step beyond the scope of this challenge, as  discussed  further in
\Cref{sec:going-beyond}.
% Our challenge problems are designed to stimulate progress on answering these questions by providing simple environments in which to demonstrate, evaluate, and compare the many tools and techniques available.
% While the challenge problems themselves are thus not of scientific interest, we expect that the best practices and mechanisations developed by solving the challenge problems will also be useful for future research.

Similarly to the authors of the POPLMark challenges, we seek to
answer several questions:
\alb{We oscillate between concurrency in general and process calculi, here and before}
\begin{enumerate}[label=\textbf{(Q\arabic*)},leftmargin=10mm]
\item\label{item:rq1} What is the current state of the art in mechanising process calculi?
\item\label{item:rq2} Which techniques and best practices can be recommended when starting formalisation projects within concurrency theory?
\item\label{item:rq3} Which improvements are needed to make mechanisation tools more user-friendly with regards to the issues faced when mechanising process calculi?
\end{enumerate}

On the whole, this benchmark seeks to advance three main goals:

\begin{enumerate}[label=\textbf{(G\arabic*)},leftmargin=10mm]
\item\label{item:goal-comperison-accessibility} To enable the comparison of
  proof mechanisation approaches, making the challenges accessible to
  mechanisation experts who may be unfamiliar with concurrency theory;

\item\label{item:goal-tutorials} To encourage the development of guidelines and
  tutorials demonstrating and comparing existing proof mechanisation
  techniques, libraries, and proof assistant features; and

\item\label{item:goal-reusability} To prioritise the exploration of mechanisation
  techniques that are reusable for future research.
\end{enumerate}
We also aim at strengthening the culture of mechanisation, by rallying the
community to collaborate on exploring and developing new tools and techniques.

We have begun collecting solutions to our challenges on our website:
%
\begin{center}
  \url{https://concurrentbenchmark.github.io/}
\end{center}
%
In the longer term, we expect to use the website for promoting best practices,
tutorials and guidelines derived from solutions to our challenges.
We encourage anyone interested to try the challenges using their
favourite tools and techniques, and to send us their solutions.

\section{Design of the Benchmark}\label{sec:design-discussion}

In this section, we outline the factors considered in designing the
benchmark challenges. We begin with some general remarks, then
describe the individual design considerations for each challenge problem,
and the evaluation criteria.
% We have identified three key aspects fundamental to mechanisations of concurrent calculi and designed our challenge problems to exercise these.

\subsubsection{General design remarks.}
Like the POPLMark and POPLMark Reloaded challenges, our challenge is not meant to be comprehensive:
applications such as multiparty session types~\cite{10.1145/2827695,10.1145/3290343}, choreographies~\cite{DBLP:journals/jar/CruzFilipeMP23}, conversation types~\cite{DBLP:journals/tcs/CairesV10}, psi-calculi~\cite{lmcs:696}, or encodings between different calculi~\cite{DBLP:journals/iandc/Gorla10,DBLP:conf/forte/CairesP16,DBLP:journals/iandc/DardhaGS17,DBLP:conf/ecoop/ScalasDHY17,DBLP:journals/iandc/KouzapasPY19,10.1145/3479394.3479407} are not directly covered.  Still, these (and other) applications need the basic techniques that our challenge problems emphasize:
as per design goal \ref{item:goal-reusability},
our problems are drawn from the basic meta-theory of process calculi (without requiring the development of new theory), and focus on well-known theorems
and results that involve interesting proof techniques that may be reused in further work.
To achieve design goal \ref{item:goal-comperison-accessibility},
we have formulated our challenge problems to explore the three aspects (linearity, scope extrusion, coinduction) independently, so that they may be solved individually and in any order;
each problem should be reasonably small and easily understood with basic knowledge of textbook concurrency theory, process calculi, and type theory.  The process calculus used in each challenge
focuses on the features that we want to emphasize, and omits all constructs
(such as choices) that would complicate the mechanisation without bringing additional tangible
benefits and insights. 
The minimality and uniformity of the calculi also allows us to target design
goal \ref{item:goal-tutorials}.

% While our challenges require reasoning about binders, which was the main topic of the original POPLMark, they also require other techniques.
% Our challenges also require reasoning about logical relations which goes above the reasoning involved in POPLMark Reloaded.

% Our challenge problems do not include reasoning about encodings. While
% this kind of reasoning is common in the field, it does not require any
% different reasoning techniques in a concurrency setting than in any
% other setting.

\subsubsection{Linearity.}
For our challenge on linear reasoning we have chosen a type preservation theorem
for a session type system, which allows us to introduce linear
reasoning with few definitions. Accordingly, we have chosen not to
include channel delegation and to use a reduction instead of a
transition system semantics.
Linearity is of course interesting in many other sub-fields of programming languages, but we have chosen to base our challenge on a session type system primarily due to the common use of session types in concurrency theory.
Inspired by Vasconcelos~\cite{Vasconcelos2012}, we use a syntax where
restriction binds two names. This presentation makes the duality
of the two names obvious in the type system.
We have chosen a simple notion of well-formedness for our challenge,
and do not, for instance, consider deadlocks. While more
sophisticated notions of well-formedness are interesting, the
proofs of these properties would complicate the challenge, distracting from the linear aspects.

\subsubsection{Scope extrusion.}
This is the challenge most closely related to the POPLMark
challenge since it concerns the properties of binders in restrictions.
It is not obvious that the techniques used to solve the original challenges about binders can be easily extended to reasoning about scope extrusion.
For example, techniques like higher-order abstract syntax, or well-scoped
de\ Bruijn indices do not have the concept of free variables and thus encoding this challenge with them requires some attention.

\subsubsection{Coinduction.}
%\fxerror{
% ``Proper'' barbs with a structural congruence in coinduction instead of LTS semantics?
%}

Our coinduction challenge concerns strong barbed bisimulation and congruence.
Though weak barbed congruence is a more common behavioural equivalence for \(\pi\)-terms, here we prefer strong equivalences to avoid the need to abstract over the number of internal transitions, % when considering the strong notions of equivalence,
thus simplifying the theory.
We have chosen not to include delegation in the coinduction challenge since it is orthogonal to our primary aim of exploring coinductive proof techniques.

\subsubsection{Evaluation criteria.}
The idea behind our benchmark is to obtain evidence towards answering questions \cref{item:rq1,item:rq2,item:rq3}. We are therefore interested in not only the solutions, but also in the experience of solving the challenges with the chosen approach.
Solutions to our challenges should be compared on three measures:
\begin{enumerate}
\item Mechanisation overhead: the amount of manually written infrastructure and setup needed to express the definitions in the mechanisation;
\item Adequacy of the formal statements in the mechanisation: whether the proven theorems are easily recognisable as the theorems from the challenge; and
\item Cost of entry for the tools and techniques employed: the difficulty of learning to use the techniques.
\end{enumerate}
Solutions to our challenges do not need to strictly follow the definitions and lemmata set out in the problem text, but solutions which deviate from the original challenges must present more elaborate argumentation for their adequacy.


\section{Existing approaches}\label{sec:approaches}

\alb{Some introductory text to lead to the literature review. \sout{We may want to move this after the next Section, if we want to mirror the 3 challenges}}
\dz{Agreed, I moved it for now.} \\
\dz{I changed the name of this section to ``Existing approaches'' from ``Motivation''. Thoughts?}

\subsubsection{Linearity.}
\input{lin}

\subsubsection{Binders.}
\input{binders}

\subsubsection{Coinduction.} \todo{}

\section{Going beyond the challenge problems}\label{sec:going-beyond}

Similar to the POPLMark and its Reloaded counterpart, this challenge
does not encompass all potential problems in the field. Our benchmark
is extendable in two aspects: it can further amalgamate and broaden
the existing challenges, and tackle aspects not yet covered by them.

% As with the POPLMark and POPLMark Reloaded challenges, this challenge does not aim to cover every possible
% problem in the area. Our benchmark can be extended in two
% dimensions: further expanding and combining the current challenges,
% and addressing features not covered by the current challenges.

\vspace{-1mm}%
\paragraph{Extending and combining the current challenges.}
While the proposed challenges try to minimise the overlap of the techniques
and aspects they explore (linearity, scope extrusion, coinduction), most
research on concurrency theory combines some or all of these. A second round of formalisations might
entail combining the features of the challenges.
We consider the following three extensions:
\emph{(1)} the addition of choice to the type level and the process level,
\emph{(2)} the addition of recursion and (for typed systems) recursive types,
and \emph{(3)} the
addition of channel delegation to those calculi that do not already
support it.%

\vspace{-1mm}%
\paragraph{Addressing new calculi and new features.}
Extending in this direction
means proposing new challenges covering different features of
process calculi, or different proof mechanisation features.
Some interesting aspects of message-passing calculi to be explored in
further challenges could be multiparty session types and
choreographies, as their meta-theory includes aspects -- \eg, well-formedness conditions on global types, partiality of end-point projection function, etc. --
that we do not address here. Also, one could easily
design a challenge that goes beyond our coinduction challenge, by
exploring different notions of bisimilarity (barbed, weak, \etc)
and trace equivalence.
%
\luca{Coinduction may also play a relevant role in supporting recursive
processes and session types. Indeed, it is often the case that session type
systems (and logics) with recursive session types (and propositions) are
naturally expressed in \emph{infinitary form} by interpreting their typing (and
proof) rules coinductively. I CAN ADD ONE OR TWO REFERENCES IF YOU FEEL IT'S APPROPRIATE}

On the mechanisation side, the present challenge proposes mechanising the
proofs of theorems. An interesting avenue to explore would be to take advantage
of other proof assistant features. For example, proof assistants can often
produce certified code (via code extraction, or compiling and running their
definitions). Additionally, while our current challenge is agnostic about proof
automation, a more specific challenge could be designed with the objective of
automating aspects of the proofs. Finally, a challenge could propose the
integration with other formal reasoning tools, such as model checkers. These
tools are in common use in the field; combining automated proofs with
proof assistants offers the potential to ease the path towards larger proofs.

Ultimately, the current challenges can be extended in several
worthwhile directions, and we look forward to a future when they
indeed are. We see the current challenge as setting
the foundation for those future extensions. It is our expectation that
the solutions of those future challenges will build on solutions
to this one.

\bibliographystyle{splncs04}
\bibliography{../references}

\clearpage
\appendix
\section{Challenges}\label{app:challenges}
\input{../challenges/challenges.tex}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
