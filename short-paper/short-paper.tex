\documentclass[runningheads]{llncs}
\synctex=1
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{mathpartir}
\usepackage{cite}
\usepackage{bm}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{hyperref}
\usepackage[inline]{enumitem}
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage[status=draft]{fixme}
\fxsetup{theme=color}
% \setlength{\textwidth}{12.4cm}
\setlength{\textheight}{19.9cm}

\input{../macros.tex}

\begin{document}

\title{The Concurrent Calculi Formalisation Benchmark}

\author{
     Marco Carbone \inst{1}\orcidID{0000-0001-9479-2632}
\and David Castro-Perez \inst{2}\orcidID{0000-0002-6939-4189}
\and Francisco Ferreira \inst{3}\orcidID{0000-0001-8494-7696}
\and Lorenzo Gheri \inst{4}\orcidID{0000-0002-3191-7722}
\and Frederik Krogsdal Jacobsen \inst{5}\orcidID{0000-0003-3651-8314}
\and Alberto Momigliano \inst{6}\orcidID{0000-0003-0942-4777}
\and Luca Padovani \inst{7}\orcidID{0000-0001-9097-1297}
\and Alceste Scalas \inst{5}\orcidID{0000-0002-1153-6164}
\and Dawit Tirore \inst{1}\orcidID{0000-0002-1997-5161}
\and Martin Vassor \inst{8}\orcidID{0000-0002-2057-0495}
\and Nobuko Yoshida \inst{8}\orcidID{0000-0002-3925-8557}
\and Daniel Zackon \inst{9}\orcidID{0009-0008-6153-2955}
}

\institute{
     IT University of Copenhagen, Copenhagen, Denmark \email{maca@itu.dk}, \email{dati@itu.dk}
\and University of Kent, Canterbury, United Kingdom \email{D.Castro-Perez@kent.ac.uk}
\and Royal Holloway, University of London, Egham, United Kingdom \email{Francisco.FerreiraRuiz@rhul.ac.uk}
\and University of Liverpool, Liverpool, United Kingdom \email{Lorenzo.Gheri@liverpool.ac.uk}
\and Technical University of Denmark, Kgs. Lyngby, Denmark \email{fkjac@dtu.dk}, \email{alcsc@dtu.dk}
\and Università degli Studi di Milano, Milan, Italy \email{momigliano@di.unimi.it}
\and Università di Camerino, Camerino, Italy \email{luca.padovani@unicam.it}
\and University of Oxford, Oxford, United Kingdom \email{martin.vassor@cs.ox.ac.uk}, \email{nobuko.yoshida@cs.ox.ac.uk}
\and McGill University, Montreal, Canada \email{daniel.zackon@mail.mcgill.ca}
}

\authorrunning{M. Carbone et al.}

\maketitle

\begin{abstract}
  The POPLMark challenge and its follow-up POPLMark Re\-loaded sparked a flurry of
  work on machine-checked proofs, and fostered the adoption of proof
  mechanisation in programming language research.  However, both POPLMark and
  POPLMark Reloaded were purposely limited in scope, with benchmark problems
  that do not address concurrency-related issues.
  %
  For this reason, we propose a new collection of benchmark problems with a
  focus on the challenges and issues that typically arise when mechanising
  message-passing concurrency using process calculi.  Our benchmark problems
  address three key topics: linearity, scope extrusion, and coinductive
  reasoning.  The goal of this new challenge is to clarify, compare, and advance
  the state of the art, fostering the adoption of proof mechanisation in future
  research on message-passing concurrency.

\keywords{Mechanisation \and Process calculi \and Benchmark \and Coinduction \and Scope extrusion \and Linearity}
\end{abstract}

\section{Introduction}
The abstract of the influential POPLMark challenge~\cite{POPLMark} starts with
an important question: \emph{``How close are we to a world where every paper on
programming languages is accompanied by an electronic appendix with
machine-checked proofs?''} The introduction of the POPLMark
challenge spearheaded a shift towards publications that include
mechanised proofs, fostering the progress of proof assistants,
libraries, and best practices.  Later on, the follow-up POPLMark
Reloaded challenge~\cite{POPLMarkReloaded} has encouraged the development of
best practices and tool support for proofs using logical relations.

The authors of both POPLMark and POPLMark Reloaded explicitly
note that their benchmarks were only a beginning.  Furthermore, they
specifically mention reasoning about concurrency using coinduction and
linear environments as points for future work.  In this spirit, in order to
further increase the reach of the POPLMark challenges, we propose a new
collection of benchmark problems specifically designed to address typical issues
that arise when mechanising message-passing concurrency using process calculi.

Several papers in the realm of process calculi already include mechanised proofs
(e.g.~\cite{DBLP:conf/pldi/Castro-Perez0GY21,DBLP:conf/tacas/CastroFY20,lmcs:9985,
  DBLP:journals/jar/CruzFilipeMP23, Tirore:2023}), or
discuss proof mechanisation techniques
(e.g.~\cite{DBLP:journals/jar/BengtsonPW16, DBLP:conf/tphol/Gay01,
  DBLP:conf/ppdp/Thiemann19, DBLP:conf/forte/ZalakainD21}).  However, our
experience is that choosing the appropriate proof mechanisation techniques and
tools remains a significant challenge with few guidelines.  This often leads
researchers towards trial-and-error, attempting sub-optimal and ad-hoc
solutions; this increases the overall effort required for proof mechanisation,
and hampers the reuse of techniques and results.
%
Therefore, it is our opinion that the research community in message-passing
concurrency (and more specifically, in process calculi) will benefit from a set
of solutions exploring different ways of mechanising typical problems in the
field.
Like the authors of the POPLMark challenges, we seek to
answer a number of questions:
\begin{enumerate}[label=\textbf{(Q\arabic*)},leftmargin=10mm]
\item\label{item:rq1} What is the current state of the art in mechanising process calculi?
\item\label{item:rq2} What techniques and best practices can be recommended when starting formalisation projects within concurrency theory?
\item\label{item:rq3} What improvements are needed to make mechanisation tools more user-friendly with regards to the issues faced when mechanising process calculi?
\end{enumerate}
We have identified three key aspects which typically cause difficulties when
mechanising concurrency theory: \emph{linearity}, \emph{scope extrusion},
and \emph{coinductive reasoning} for infinite behaviours.
Our benchmark problems are designed to focus on these aspects (discussed
in detail in \cref{app:challenges}), with three main goals:

\begin{enumerate}[label=\textbf{(G\arabic*)},leftmargin=10mm]
\item\label{item:goal-comperison-accessibility} Enable the comparison of
  different proof mechanisation approaches, making the challenges accessible to
  mechanisation experts who may not be familiar with concurrency theory.

\item\label{item:goal-tutorials} Encourage the development of guidelines and
  tutorials demonstrating and comparing the many available proof mechanisation
  techniques, libraries, and proof assistant features.

\item\label{item:goal-reusability} Prioritise the exploration of mechanisation
  techniques that may be useful and reusable for future research.
\end{enumerate}
We also aim at strengthening the culture of mechanisation, by rallying the
community to collaborate on exploring and developing new tools and techniques.

The three aspects we selected (linearity, scope extrusion, coinduction) are of
course not the only ones that may cause issues in mechanisations --- but they
are fundamental to concurrency theory, and they emerge in most mechanisations.
The mechanisation of novel research results often requires addressing more than
just one of these aspects at once --- and we see the combination of techniques
as a next step beyond the scope of this challenge (we discuss this in
\cref{sec:going-beyond}).

% Our challenge problems are designed to stimulate progress on answering these questions by providing simple environments in which to demonstrate, evaluate, and compare the many tools and techniques available.
% While the challenge problems themselves are thus not of scientific interest, we expect that the best practices and mechanisations developed by solving the challenge problems will also be useful for future research.

We have begun collecting solutions to our challenges on our website:
%
\begin{center}
  \url{https://concurrentbenchmark.github.io/}
\end{center}
%
In the longer term, we expect to use the website for promoting best practices,
tutorials and guidelines derived from solutions to our challenges.
We encourage anyone interested to try the challenges using their
favourite tools and techniques, and to send us their solutions.

\paragraph{Outline of this paper.}
We discuss our design choices in \cref{sec:design-discussion}, and possible extensions and further topics in \cref{sec:going-beyond}.
The actual challenges are available in \cref{app:challenges}.

\section{Design of the benchmark}\label{sec:design-discussion}

In this section, we outline the factors considered in designing the
benchmark challenges. We start with some general remarks, then
describe the individual design considerations for each challenge problem,
and the evaluation criteria.
% We have identified three key aspects fundamental to mechanisations of concurrent calculi and designed our challenge problems to exercise these.

\subsubsection{General design remarks.}
Like the POPLMark and POPLMark Reloaded challenges, our challenge is not meant to be comprehensive:
applications such as multiparty session types~\cite{10.1145/2827695,10.1145/3290343}, choreographies~\cite{DBLP:journals/jar/CruzFilipeMP23}, conversation types~\cite{DBLP:journals/tcs/CairesV10}, psi-calculi~\cite{lmcs:696}, or encodings between different calculi~\cite{DBLP:journals/iandc/Gorla10,DBLP:conf/forte/CairesP16,DBLP:journals/iandc/DardhaGS17,DBLP:conf/ecoop/ScalasDHY17,DBLP:journals/iandc/KouzapasPY19,10.1145/3479394.3479407} are not directly covered.  Still, these (and other) applications need the basic techniques that our challenge problems exercise:
as per our design goal \ref{item:goal-reusability},
our problems are drawn from the basic metatheory of process calculi (without requiring the development of new theory), and focus on well-known theorems
and results that involve interesting proof techniques that may be reused in further work.
To achieve our design goal \ref{item:goal-comperison-accessibility},
we have drafted our challenge problems to exercise the three aspects (linearity, scope extrusion, coinduction) independently, so that they can be solved individually and in any order;
each problem should be reasonably small and easy to understand with basic knowledge of textbook concurrency theory, process calculi, and type theory.  The process calculus used in each challenge
focuses on the features that we want to exercise, and omits all constructs
(such as choices) that would complicate the mechanisation without bringing tangible
benefits and insights.
The minimality and uniformity of the calculi also allows us to target the design
goal \ref{item:goal-tutorials}.

% While our challenges require reasoning about binders, which was the main topic of the original POPLMark, they also require other techniques.
% Our challenges also require reasoning about logical relations which goes above the reasoning involved in POPLMark Reloaded.

% Our challenge problems do not include reasoning about encodings. While
% this kind of reasoning is common in the field, it does not require any
% different reasoning techniques in a concurrency setting than in any
% other setting.

\subsubsection{Linearity.}
For our challenge on linear reasoning we have chosen a type preservation theorem
for a session type system since this allows us to involve linear
reasoning without many definitions. Accordingly, we have chosen not to
include channel delegation and to use a reduction instead of a
transition system semantics.
Linearity is of course interesting in many other subfields of programming languages, but we have chosen to base our challenge on a session type system primarily due to the common use of session types in concurrency theory.
Inspired by Vasconcelos~\cite{Vasconcelos2012}, we use a syntax where
restriction binds two names. This presentation makes the duality
of the two names obvious in the type system.
We have chosen a simple notion of well-formedness for our challenge,
and do not for instance consider deadlocks. While more
sophisticated notions of well-formedness are interesting, the
proofs of these properties are more complicated and would make
the challenge more difficult and less focused on the linear
aspects.

\subsubsection{Scope extrusion.}
This is the challenge most closely related to the POPLMark
challenge since it concerns the properties of binders in restrictions.
It is not clear that the techniques used to solve the original challenges about binders can be easily extended to reasoning about scope extrusion.
For example, techniques like Higher Order Abstract Syntax, or well-scoped
De\ Bruijn indices do not have the concept of free variables and thus encoding this challenge with them requires some attention.

\subsubsection{Coinduction.}
%\fxerror{
% ``Proper'' barbs with a structural congruence in coinduction instead of LTS semantics?
%}

Our coinduction challenge concerns strong barbed bisimulation and congruence.
Though weak barbed congruence is a more common behavioural equivalence for \(\pi\)-terms, here we prefer strong equivalences to avoid the need to abstract over the number of internal transitions, % when considering the strong notions of equivalence,
thus simplifying the theory.
We have chosen not to include delegation in the coinduction challenge since it is orthogonal to our primary aim of exploring coinductive proof techniques.

\subsubsection{Evaluation criteria.}
The idea of our benchmark is to obtain evidence towards answering questions \cref{item:rq1,item:rq2,item:rq3}: therefore, we are interested in not only the solutions, but in the experience of solving the challenges with the chosen approach.
Solutions to our challenges should be compared on three measures:
\begin{itemize}
\item the mechanisation overhead, i.e.~the amount of manually written infrastructure and setup needed to express the definitions in the mechanisation; \item the adequacy of the formal statements in the mechanisation, i.e.~whether the proven theorems are easily recognisable as the theorems from the challenge; \item the cost of entry for the tools and techniques employed, i.e.~the difficulty of learning to use the techniques.
\end{itemize}
Solutions to our challenges do not need to strictly follow the definitions and lemmas set out in the problem text, but solutions which deviate from the original challenges need to present more elaborate argumentation for their adequacy.

\section{Going beyond the challenge problems}\label{sec:going-beyond}

As with the POPLMark and POPLMark Reloaded challenges, this challenge does not aim to cover every possible
problem in the area. Our benchmark can be extended in two
dimensions: further expanding and combining the current challenges,
and addressing features not covered by the current challenges.

\vspace{-1mm}%
\paragraph{Extending and combining the current challenges.}
The proposed challenges try to minimise the overlap of the techniques
and aspects they exercise (linearity, scope extrusion, coinduction) --- but most
research on concurrency theory combines some or all such aspects. A second round of formalisations could
entail combining the features of the challenges.
In \cref{tab:extensions} we consider the following three extensions:
\emph{(1)} the addition of choice to the type level and the process level,
\emph{(2)} the addition of recursion (and recursive types for typed systems),
and \emph{(3)} the
addition of channel delegation to those calculi that do not already
support it.

\begin{table}[btp]
  \caption{Possible extensions of the challenges. Each suitable extension is marked ``+''. \label{tab:extensions}}
  \begin{center}\small
    \vspace{-4mm}%
    \begin{tabular}{|r|c|c|c|}
      \hline
      & Linearity & Scope extrusion & Coinduction \\
      \hline
      Choice & $+$ & $+$  & $+$ \\
      \hline
      Recursive types & $+$  & $+$ & \\
      \hline
      Delegation & $+$ & & $+$ \\
      \hline
    \end{tabular}
    \vspace{-3mm}%
  \end{center}
\end{table}

\vspace{-1mm}%
\paragraph{Addressing new calculi and new features.}
Extending in this dimension
means proposing new challenges covering different features of
process calculi, or different proof mechanisation features.
Some interesting aspects of message passing calculi to explore in
further challenges could be multiparty session types and
choreographies, as their meta-theory includes aspects
that we do not cover here (e.g.: well-formed global types,
projection as a partial function) --- although some aspects
that we cover here do appear in their theory. Also, one could easily
design a challenge that goes beyond our coinduction challenge, by
exploring different notions of bisimilarity (barbed, weak, etc.),
and trace equivalence.

On the mechanisation side, the present challenge proposes mechanising the
proofs of theorems. An interesting avenue to explore would be to take advantage
of other proof assistant features. For example, proof assistants can often
produce certified code (via code extraction, or compiling and running their
definitions). Additionally, while our current challenge is agnostic about proof
automation, a more specific challenge could be designed with the objective of
automating aspects of the proofs. Finally, a challenge could propose the
integration with other formal reasoning tools, namely model checkers. These
tools are in common use in the field --- and combining automated proofs with
proof assistants offers the potential to ease the path towards larger proofs.

Ultimately, the current challenges can be extended in several
worthwhile directions, and we look forward to a future when they
indeed are extended. We see the current challenge as setting
the foundation for those future extensions. It is our expectation that
the solutions of those future challenges will build on solutions
to this challenge.

\bibliographystyle{splncs04}
\bibliography{../references}

\clearpage
\appendix
\section{Challenges}\label{app:challenges}
\input{../challenges/challenges.tex}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
